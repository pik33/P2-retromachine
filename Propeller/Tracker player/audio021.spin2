' A Paula inspired sample based synthesizer/audio driver for a P2
' v. 0.21 alpha - 20220129
' MIT license
' Piotr Kardasz pik33@o2.pl
' 16 16-bit channels now
'-------------------------------------------------------------------
con

'319220550    =3546895, change to NTSC freq if needed
'322159050 ' This is 90x Amiga NTSC = 3579545
_clkfreq = 354693878  ' This is 100x Amiga PAL 3546895
' audio pins TODO: make a variable for start() instead of const

left= 8
right=9


c4=262
d4=294
e4=330
f4=349
g4=392
a4=440
h4=494

var

'channel+0  long current spl pointer - bit31=1 when 8bit spl
'channel+4  long sample
'channel+8  long sample start 
'channel+12 long loop start
'channel+16 long loop end
'channel+20 word volume
'channel+22 word pan
'channel+24 word synthfreq
'channel+26 word skip
'channel+28 long reserved
'

long channel1[8]
long channel2[8]
long channel3[8]
long channel4[8]
long channel5[8]
long channel6[8]
long channel7[8]
long channel8[8]
long channel9[8]
long channel10[8]
long channel11[8]
long channel12[8]
long channel13[8]
long channel14[8]
long channel15[8]
long channel16[8]


long primes[8]

'----------------------------------------------------------------
'------------  Alpha testing the thing --------------------------
'---------------------------------------------------------------- 

pub test

{{
start()
waitms(500)
repeat
  play(c4,5000,16384)
  play(d4,5000,16384)
  play(e4,5000,16384)
  play(f4,5000,16384)
  play(g4,5000,16384)
  play(a4,5000,16384)
  play(h4,5000,16384)
  play(2*c4,500,16384)
  play(c4,500,0)
  play(2*c4,500,16384)
  play(h4,500,16384)
  play(a4,500,16384)
  play(g4,500,16384)
  play(f4,500,16384)
  play(e4,500,16384)
  play(d4,500,16384)
  play(c4,500,16384)
  play(c4,500,0)

 
 
'----------------------------------------------------------------
'------------  An alpha test playing procedure ------------------
'------------  Plays sine waves in allchannels ------------------
'------------  makes a harmonic sound ---------------------------
'---------------------------------------------------------------- 

pub play(ff,time,vol) |ilss,ss,ssf,base,iii

' Test play 

ss:=64
ssf:=(ss*3568945)/(ff*2048)



base:=@channel1[0]

repeat iii from 0 to 0
  long [base+32*iii]:=0
  long [base+32*iii+4]:=0 
  long[base+32*iii+12]:=16
  long[base+32*iii+16]:=2048+16
  word[base+32*iii+20]:=vol/(iii+1)
  word[base+32*iii+22]:=8192
  word[base+32*iii+24]:=ssf
  word[base+32*iii+26]:=ss*(iii+1)
  long [base+32*iii+8]:=@sinewave | $C0000000  
repeat time
    waitms(1)

}}
'--------------------------------------------------------------
'---------- Init the variables, start the cog. ----------------
'--------------------------------------------------------------

pub start() :cog,base | iii

base:=@channel1[0]

repeat iii from 0 to 15
  long [base+32*iii]:=0
  long [base+32*iii+4]:=0
  long[base+32*iii+12]:=0
  long[base+32*iii+16]:=2 
  word[base+32*iii+20]:=0
  word[base+32*iii+22]:=8192
  word[base+32*iii+24]:=400+2*iii
  word[base+32*iii+26]:=2
  long [base+32*iii+8]:=@null | $C0000000
  
cog:=coginit(16,@audio,@channel1)
waitms(100)
return cog,base

'--------------------------------------------------------------
'------ PASM driver code --------------------------------------
'-------------------------------------------------------------- 

dat

audio       org     0
            mov     ptrb,#0
            wrpin   dac,#left       ' Noise dither DACs at clk/90
            wxpin   #100,#left
            wrpin   dac,#right
            wxpin   #100,#right
            dirh    #left addpins 1
            setse1  #%001<<6 + left ' Set the event - DAC empty
            mov     ijmp1,#isr1     ' Init the interrupt
            setint1 #4              ' Interrupt from DAC empty event
            
'---------------------------------------------------------------------------------        
'----------------- The main loop -------------------------------------------------
'---------------------------------------------------------------------------------

loop        cmp     time0,a21000000 wc  ' time counter overflow protection
      if_c  jmp     #loop1
  
            mov     cn,#17
p402        altd    cn,#a21000000
            sub     0-0,a20000000
            djnz    cn,#p402
    
loop1       mov     cn,#0             ' Find the channel to compute
            mov     ct,time1           ' with the lowest next sample time
            fle     ct,time2 wcz       ' How to size-optimize this???
    if_c    mov     cn,#1
            fle     ct,time3 wcz
    if_c    mov     cn,#2     
            fle     ct,time4 wcz
    if_c    mov     cn,#3
            fle     ct,time5 wcz
    if_c    mov     cn,#4
            fle     ct,time6 wcz
    if_c    mov     cn,#5
            fle     ct,time7 wcz
    if_c    mov     cn,#6
            fle     ct,time8 wcz
    if_c    mov     cn,#7
            fle     ct,time9 wcz
    if_c    mov     cn,#8
            fle     ct,time10 wcz
    if_c    mov     cn,#9
            fle     ct,time11 wcz
    if_c    mov     cn,#10
            fle     ct,time12 wcz
    if_c    mov     cn,#11
            fle     ct,time13 wcz
    if_c    mov     cn,#12
            fle     ct,time14 wcz
    if_c    mov     cn,#13
            fle     ct,time15 wcz
    if_c    mov     cn,#14
            fle     ct,time16 wcz
    if_c    mov     cn,#15



'----------------------------------------------------------------------------------
'------------- Compute channel samples --------------------------------------------
'----------------------------------------------------------------------------------


p401        mov     channeladd,cn              ' todo: reset channel times to enable proper streamed stereo audio
            shl     channeladd,#5
            add     ptra,channeladd

            setq    #7               
            rdlong  pointer0,ptra
            
     	    getword apan0,volpan0,#1           ' extract vol,pan,skip and freq from longs 
    	    getword avol0,volpan0,#0
	    getword askip0,freqskip0,#1    	    
	    getword afreq0,freqskip0,#0

            alts    cn, #time1
            mov     dt0,0-0   
            sub     dt0,time0

            altd    cn, #time1
            add     0-0,afreq0  	

            add     pointer0,askip0
            cmp     pointer0,lend0 wcz
    if_ge   sub     pointer0,lend0	        
    if_ge   add     pointer0,lstart0       
            mov     qq,pointer0
            add     qq,sstart0

            testb   sstart0,#31 wz

    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,avol0
            mov     spl,0-0
 
            scas    spl,apan0
            mov     ls0,0-0
 
            altd    cn,#ls1
            mov     0-0,ls0
             
            mov     qq,##16384
            sub     qq,apan0
            scas    spl,qq
            mov     rs0, 0-0

            altd    cn,#rs1
            mov     0-0,rs0

            setword sample0,rs0,#1
            setword sample0,ls0,#0
            
            bitl   sstart0, #30 wcz            
    if_z    mov    pointer0, #0  
    if_z    wrlong sstart0, ptra[2]
p403        setq #1
     
            wrlong  pointer0,ptra
            sub     ptra, channeladd
            jmp     #p101
                       
            
                      
'------------------------ Channels end here --------------------       

' Now add all channels and put the sample to the buffer    


p101        cmp     oldt0,time0 wz '  If 2 samples have the same time, update instead of write
    if_z    decmod front, ##511        ' 
 '   if_z    and     front,#511     
           
            wrlong front,#$60

            mov     rs,#0            ' Mix all channels to rs and ls
            mov     ls,#0
            add     rs,rs1
            add     rs,rs2            'todo: in channel computing, mov rs to oldrs, hrer sub oldrs, abb newrs
            add     rs,rs3
            add     rs,rs4
            add     rs,rs5
            add     rs,rs6
            add     rs,rs7
            add     rs,rs8
            add     rs,rs9
            add     rs,rs10
            add     rs,rs11
            add     rs,rs12
            add     rs,rs13
            add     rs,rs14
            add     rs,rs15
            add     rs,rs16

           
            add     ls,ls1
            add     ls,ls2
            add     ls,ls3
            add     ls,ls4
            add     ls,ls5
            add     ls,ls6
            add     ls,ls7
            add     ls,ls8
            add     ls,ls9
            add     ls,ls10
            add     ls,ls11
            add     ls,ls12
            add     ls,ls13
            add     ls,ls14
            add     ls,ls15
            add     ls,ls16

 		
            bitnot  ls,#15            ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
            bitnot  rs,#15		      ' and these with $FFFF if a filter should be applied
		    
            setword rs,ls,#1         ' Pack L and R to one long    		
            mov oldsample, newsample
            mov newsample, rs

            mov     oldt0,time0      ' update global time
            add     time0,dt0    
                                      ' now push dt0 samples to the buffer
            cmp      dt0,#0 wz
    if_z    jmp      #loop1
            mov      t1,dt0
  
p301        alts    ptrb,#511          ' checking if the buffer is full - Wuerfel_21's magic stuff
            cmpr    front, #0-0 wcz
    if_e    jmp     #p301    
			    
            wrlut   oldsample, front
       incmod front, ##511
            djnz    t1,#p301
            
            jmp     #loop            'loop

'-------------------------------------------------------------------------
'------------------ This is the end of the main loop ---------------------
'-------------------------------------------------------------------------

'--------------------------------------------------------------------------
'------ Interrupt service -------------------------------------------------
'------ Output the sample, get the next one if exists ---------------------
'--------------------------------------------------------------------------

isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
            wypin   rsample,#right       '4
           
            cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
    if_e    reti1                        '8/10

            rdlut   lsnext,ptrb++        '11    else read the sample and its time from LUT
        '    wrlong  ptrb,#$60
            and     ptrb, #511
            getword rsample,lsnext,#1    '13
            getword lsample,lsnext,#0    '15
            reti1                        '17/19 
          
'---------------------------------------------------------------------------
'-------- End of interrupt -------------------------------------------------
'---------------------------------------------------------------------------    


'---------------------------------------------------------------------------
'------- Variables ---------------------------------------------------------
'---------------------------------------------------------------------------

' constants

hp long 0
lp long 0
bp long 0
a20000000   long $10000000
a21000000   long $11000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before

' Time variables

time0       long 0    ' Global sample computing time
time1       long 1    ' Local channels time
time2       long 2
time3       long 3
time4       long 4
time5       long 5
time6       long 6
time7       long 7
time8       long 8
time9       long 9
time10       long 10
time11       long 11
time12      long 12
time13       long 13
time14       long 14
time15      long 15
time16      long 16


oldsample long 0
newsample long 0
'
t1 long 0
t2 long 0
'
nrsample long 0
nlsample long 0
'
channeladd long 0


front       long 0

' temporary variables 
'
qq          long 0
spl         long 0

' circular buffer in LUT


'

' Interrupt ISR variables


lsample     long 0
rsample     long 0
lsnext      long 0
rsnext      long 0 


pointer0    long 0
sample0     long 0
sstart0     long 0     ' start pointer and type at bit 31
lstart0     long 0
lend0       long 0
volpan0     long 0
freqskip0   long 0
dummy0      long 0

afreq0      long 0
askip0      long 0
avol0       long 0
apan0       long 0

oldt0       long $FFFFFFFF    'Temporary time variables
cn          long 0
ct          long 0
dt0         long 0

' Samples
ls0         long 0
rs0         long 0
channel     long 0
ls          long 0    ' Global sample variable
rs          long 0

ls1         long 0    ' Channel samples
ls2         long 0
ls3         long 0
ls4         long 0
ls5         long 0
ls6         long 0
ls7         long 0
ls8         long 0
ls9         long 0    ' Channel samples
ls10         long 0
ls11         long 0
ls12        long 0
ls13         long 0
ls14         long 0
ls15        long 0
ls16        long 0


rs1         long 0
rs2         long 0
rs3         long 0
rs4         long 0
rs5         long 0
rs6         long 0
rs7         long 0
rs8         long 0
rs9         long 0
rs10        long 0
rs11        long 0
rs12         long 0
rs13         long 0
rs14        long 0
rs15         long 0
rs16        long 0




dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
'dac        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   

'-----------------------------------------------------------------------------------------
'------ PASM driver ends here ------------------------------------------------------------
'----------------------------------------------------------------------------------------- 

'
dat 

null  			long 	0,0           ' for channel reset
'sinewave 		file 	"sinus.s2"    ' for testing
