' A Paula inspired sample based synthesizer/audio driver for a P2
' v. 0.15 alpha - 20220111
' MIT license
' Piotr Kardasz pik33@o2.pl
'-------------------------------------------------------------------
con

' _clkfreq = 319220550 ' This is 90x Amiga PAL   =3546895, change to NTSC freq if needed
'_clkfreq = 322159050 ' This is 90x Amiga NTSC = 3579545
_clkfreq = 354693878
' audio pins TODO: make a variable for start() instead of const

left= 14
right=15


c4=262
d4=294
e4=330
f4=349
g4=392
a4=440
h4=494

var

' channel registers. 9 regs per channel: TODO: reduce the memory usage for this 

'0 - samplestart   - a pointer to the sample start
'1 - sampletype    - 0: 16 bit, 1 8 bit, both signed
'2 - loopstart     - loop start
'3 - loopend       - loop end, has to be >=loopstart+2
'4 - volume        - sample volume, 16384=1
'5 - pan           - 0..16384
'6 - synthfreq     - the frequency divider for the channel. The channel sample rate will be 3546895 or 3579545 Hz divided by this
'7 - skip          - value to add to the phase accumulator for the next sample, 1 for 8 bit, 2 for 16 bit, more for special purposes
'8 - cmd           - 0 here will reset and keep the phase accumulator at 0. Use before the new sample or to restart the current one if it loops

var
long channel1[9]
long channel2[9]
long channel3[9]
long channel4[9]
long channel5[9]
long channel6[9]
long channel7[9]
long channel8[9]



'----------------------------------------------------------------
'------------  Alpha testing the thing --------------------------
'---------------------------------------------------------------- 

pub test

start()
waitms(500)
repeat
  play(c4,500,16384)
  play(d4,500,16384)
  play(e4,500,16384)
  play(f4,500,16384)
  play(g4,500,16384)
  play(a4,500,16384)
  play(h4,500,16384)
  play(2*c4,500,16384)
  play(c4,500,0)
  play(2*c4,500,16384)
  play(h4,500,16384)
  play(a4,500,16384)
  play(g4,500,16384)
  play(f4,500,16384)
  play(e4,500,16384)
  play(d4,500,16384)
  play(c4,500,16384)
  play(c4,500,0)

 
 
'----------------------------------------------------------------
'------------  An alpha test playing procedure ------------------
'------------  Plays sine waves in allchannels ------------------
'------------  makes a harmonic sound ---------------------------
'---------------------------------------------------------------- 

pub play(ff,time,vol) |ilss,ss,ssf

' Test play 

ilss:=40000/ff
ss:=2*(1024/ilss)
if ss<2
  ss:=2
ssf:=(ss*3568945)/(ff*2048)

channel1[0]:=@sinewave
channel1[1]:=0
channel1[2]:=16
channel1[3]:=2048+16
channel1[4]:=vol
channel1[5]:=8192
channel1[6]:= ssf
channel1[7]:= ss

channel2[0]:=@sinewave
channel2[1]:=0
channel2[2]:=16
channel2[3]:=2048+16
channel2[4]:=vol/2
channel2[5]:=8192
channel2[6]:= ssf
channel2[7]:= ss*2

channel3[0]:=@sinewave
channel3[1]:=0
channel3[2]:=16
channel3[3]:=2048+16
channel3[4]:=vol/3
channel3[5]:=8192
channel3[6]:= ssf
channel3[7]:= ss*3

channel4[0]:=@sinewave
channel4[1]:=0
channel4[2]:=16
channel4[3]:=2048+16
channel4[4]:=vol/4
channel4[5]:=8192
channel4[6]:= ssf
channel4[7]:= ss*4

channel5[0]:=@sinewave
channel5[1]:=0
channel5[2]:=16
channel5[3]:=2048+16
channel5[4]:=vol/5
channel5[5]:=8192
channel5[6]:= ssf
channel5[7]:= ss*5

channel6[0]:=@sinewave
channel6[1]:=0
channel6[2]:=16
channel6[3]:=2048+16
channel6[4]:=vol/6
channel6[5]:=8192
channel6[6]:= ssf
channel6[7]:= ss*6

channel7[0]:=@sinewave
channel7[1]:=0
channel7[2]:=16
channel7[3]:=2048+16
channel7[4]:=vol/7
channel7[5]:=8192
channel7[6]:= ssf
channel7[7]:= ss*7

channel8[0]:=@sinewave
channel8[1]:=0
channel8[2]:=16
channel8[3]:=2048+16
channel8[4]:=vol/8
channel8[5]:=8192
channel8[6]:= ssf
channel8[7]:= ss*8





channel1[8]:=0
channel2[8]:=0
channel3[8]:=0
channel4[8]:=0
channel5[8]:=0
channel6[8]:=0
channel7[8]:=0
channel8[8]:=0
waitus(200)
channel1[8]:=1
channel2[8]:=1
channel3[8]:=1
channel4[8]:=1
channel5[8]:=1
channel6[8]:=1
channel7[8]:=1
channel8[8]:=1

waitms(time)



'--------------------------------------------------------------
'---------- Init the variables, start the cog. ----------------
'--------------------------------------------------------------

pub start() :cog


channel1[0]:=@null
channel1[1]:=0
channel1[2]:=0
channel1[3]:=2
channel1[4]:=0
channel1[5]:=8192
channel1[6]:=101
channel1[7]:=2

channel2[0]:=@null
channel2[1]:=0
channel2[2]:=0
channel2[3]:=2
channel2[4]:=0
channel2[5]:=8192
channel2[6]:=103
channel2[7]:=2

channel3[0]:=@null
channel3[1]:=0
channel3[2]:=0
channel3[3]:=2
channel3[4]:=0
channel3[5]:=8192
channel3[6]:=107
channel3[7]:=2

channel4[0]:=@null
channel4[1]:=0
channel4[2]:=0
channel4[3]:=2
channel4[4]:=0
channel4[5]:=8192
channel4[6]:=109
channel4[7]:=2
channel4[8]:=1

channel5[0]:=@null
channel5[1]:=0
channel5[2]:=0
channel5[3]:=2
channel5[4]:=0
channel5[5]:=8192
channel5[6]:=113
channel5[7]:=2

channel6[0]:=@null
channel6[1]:=0
channel6[2]:=0
channel6[3]:=2
channel6[4]:=0
channel6[5]:=8192
channel6[6]:=127
channel6[7]:=2

channel7[0]:=@null
channel7[1]:=0
channel7[2]:=0
channel7[3]:=2
channel7[4]:=0
channel7[5]:=8192
channel7[6]:=131
channel7[7]:=2

channel8[0]:=@null
channel8[1]:=0
channel8[2]:=0
channel8[3]:=2
channel8[4]:=0
channel8[5]:=8192
channel8[6]:=137
channel8[7]:=2

channel1[8]:=1
channel2[8]:=1
channel3[8]:=1
channel4[8]:=1
channel5[8]:=1
channel6[8]:=1
channel7[8]:=1
channel8[8]:=1

cog:=coginit(16,@audio,@channel1)
return cog

'--------------------------------------------------------------
'------ PASM driver code --------------------------------------
'-------------------------------------------------------------- 

dat

audio       org     0
			mov ptrb,#0
			setq #71
            rdlong  sstart1,ptra
            wrpin   dac,#left       ' Noise dither DACs at clk/90
            wxpin   #100,#left
            wrpin   dac,#right
            wxpin   #100,#right
            dirh    #left addpins 1
            setse1  #%001<<6 + left ' Set the event - DAC empty
            mov     ijmp1,#isr1     ' Init the interrupt
            setint1 #4              ' Interrupt from DAC empty event
            
'---------------------------------------------------------------------------------        
'----------------- The main loop -------------------------------------------------
'---------------------------------------------------------------------------------

loop        cmp     time0,a21000000 wc  ' time counter overflow protection
      if_c  jmp     #loop1
      
            sub     time1,a20000000
            sub     time2,a20000000
            sub     time3,a20000000
            sub     time4,a20000000
            sub     time5,a20000000
            sub     time6,a20000000
            sub     time7,a20000000
            sub     time8,a20000000
            sub     time0,a20000000
    
loop1       and     p1,acmd1            ' cmd=0 resets the phase accumulator
            and     p2,acmd2
            and     p3,acmd3
            and     p4,acmd4
            and     p5,acmd5
            and     p6,acmd6
            and     p7,acmd7
            and     p8,acmd8
       
            mov     cn,#p201           ' Find the channel to compute
            mov     ct,time1           ' with the lowest next sample time
            fle     ct,time2 wcz   
    if_c    mov     cn,#p202 
            fle     ct,time3 wcz
    if_c    mov     cn,#p203     
            fle     ct,time4 wcz
    if_c    mov     cn,#p204
            fle     ct,time5 wcz
    if_c    mov     cn,#p205 
            fle     ct,time6 wcz
    if_c    mov     cn,#p206
            fle     ct,time7 wcz
    if_c    mov     cn,#p207
            fle     ct,time8 wcz
    if_c    mov     cn,#p208 
 
            jmp     cn
   
'----------------------------------------------------------------------------------
'------------- Compute channel samples --------------------------------------------
'----------------------------------------------------------------------------------
	
' ------------  Channel 1
 
p201        setq    #8              ' Read channel regs from the hub
            rdlong  sstart1,ptra

            mov     dt0,time1      ' compute the delta to add to the global time
            sub     dt0,time0
            add     time1,freq1    ' compute the next channel time	
	        
            add     p1,askip1      ' update the phase accumulator
            cmp     p1,lend1 wcz   ' substract the loop length if over the loop end
    if_ge   sub     p1,lend1	        
    if_ge   add     p1,lstart1       
            mov     qq,p1          ' compute the pointer to the next sample
            add     qq,sstart1
            
            cmp     type1,#0 wz    ' check the sample type
    if_nz   rdbyte  spl,qq         ' not zero=8 bit
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq         ' zero=16 bit. TODO: more types? signed/unsigned, etc... 

            scas    spl,vol1       ' apply the volume
            mov     spl,0-0

            scas    spl,apan1      ' apply the pan
            mov     ls1,0-0
            mov     qq,##16384
            sub     qq,apan1
            scas    spl,qq
            mov     rs1,0-0
            
            jmp     #p101              
	    	
' ------------  Channel 2
 
p202        add     ptra,#36
            setq    #8              
            rdlong  sstart2,ptra
            sub     ptra, #36

            mov     dt0,time2
            sub     dt0,time0
            add     time2,freq2  	
	        
            add     p2,askip2
            cmp     p2,lend2 wcz
    if_ge   sub     p2,lend2	        
    if_ge   add     p2,lstart2       
            mov     qq,p2
            add     qq,sstart2

            cmp     type2,#0 wz
    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,vol2
            mov     spl,0-0
            
            scas    spl,apan2
            mov     ls2,0-0
            mov     qq,##16384
            sub     qq,apan2
            scas    spl,qq
            mov     rs2,0-0
            
            jmp     #p101

' ------------  Channel 3
 
p203        add     ptra,#36*2
            setq    #8               
            rdlong  sstart3,ptra
            sub     ptra, #36*2

            mov     dt0,time3
            sub     dt0,time0
            add     time3,freq3  	
	        
            add     p3,askip3
            cmp     p3,lend3 wcz
    if_ge   sub     p3,lend3	        
    if_ge   add     p3,lstart3       
            mov     qq,p3
            add     qq,sstart3
            
            cmp     type3,#0 wz
    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,vol3
            mov     spl,0-0
    	
            scas    spl,apan3
            mov     ls3,0-0
            
            mov     qq,##16384
            sub     qq,apan3
            scas    spl,qq
            mov     rs3,0-0

            jmp     #p101
            
' ------------  Channel 4
 
p204        add     ptra,#36*3
            setq    #8               
            rdlong  sstart4,ptra
            sub     ptra, #36*3

            mov     dt0,time4
            sub     dt0,time0
            add     time4,freq4  	
	        
            add     p4,askip4
            cmp     p4,lend4 wcz
    if_ge   sub     p4,lend4	        
    if_ge   add     p4,lstart4       
            mov     qq,p4
            add     qq,sstart4
            
            cmp     type4,#0 wz
    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,vol4
            mov     spl,0-0
    	
            scas    spl,apan4
            mov     ls4,0-0
            
            mov     qq,##16384
            sub     qq,apan4
            scas    spl,qq
            mov     rs4,0-0

            jmp     #p101
            
' ------------  Channel 5
 
p205        add     ptra,#36*4
            setq    #8               
            rdlong  sstart5,ptra
            sub     ptra, #36*4

            mov     dt0,time5
            sub     dt0,time0
            add     time5,freq5  	

	        
            add     p5,askip5
            cmp     p5,lend5 wcz
    if_ge   sub     p5,lend5	        
    if_ge   add     p5,lstart5       
            mov     qq,p5
            add     qq,sstart5
            
            cmp     type5,#0 wz
    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,vol5
            mov     spl,0-0
    	
            scas    spl,apan5
            mov     ls5,0-0
            
            mov     qq,##16384
            sub     qq,apan5
            scas    spl,qq
            mov     rs5,0-0

            jmp     #p101
  
' ------------  Channel 6
 
p206        add     ptra,#36*5
            setq    #8              
            rdlong  sstart6,ptra
            sub     ptra, #36*5

            mov       dt0,time6
            sub     dt0,time0
            add     time6,freq6  	
	        
            add     p6,askip6
            cmp     p6,lend6 wcz
    if_ge   sub     p6,lend6	        
    if_ge   add     p6,lstart6       
            mov     qq,p6
            add     qq,sstart6
            
            cmp     type6,#0 wz
    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq
          
            scas    spl,vol6
            mov     spl,0-0
    	
            scas    spl,apan6
            mov     ls6,0-0
            
            mov     qq,##16384
            sub     qq,apan6
            scas    spl,qq
            mov     rs6,0-0

            jmp     #p101
            
' ------------  Channel 7
 
p207        add     ptra,#36*6
            setq    #8              ' 
            rdlong  sstart7,ptra
            sub     ptra, #36*6

            mov     dt0,time7
            sub     dt0,time0
            add     time7,freq7  	
	        
            add     p7,askip7
            cmp     p7,lend7 wcz
    if_ge   sub     p7,lend7	        
    if_ge   add     p7,lstart7       
            mov     qq,p7
            add     qq,sstart7
            
            cmp     type7,#0 wz
    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,vol7
            mov     spl,0-0
    	
            scas    spl,apan7
            mov     ls7,0-0
            
            mov     qq,##16384
            sub     qq,apan7
            scas    spl,qq
            mov     rs7,0-0

            jmp     #p101     
                   
' ------------  Channel 8
 
p208        add     ptra,#36*7
            setq    #8              
            rdlong  sstart8,ptra
            sub     ptra, #36*7
 
            mov     dt0,time8      '* time8
            sub     dt0,time0      
            add     time8,freq8    '* freq8	
	        
            add     p8,askip8      '* skip8 *p8
            cmp     p8,lend8 wcz   '* lend8
    if_ge   sub     p8,lend8	        
    if_ge   add     p8,lstart8     '* lstart8  
            mov     qq,p8    
            add     qq,sstart8
            
            cmp     type8,#0 wz
    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,vol8
            mov     spl,0-0
    	
            scas    spl,apan8
            mov     ls8,0-0
            
            mov     qq,##16384
            sub     qq,apan8
            scas    spl,qq
            mov     rs8,0-0

            jmp     #p101            
            
'------------------------ Channels end here --------------------       

' Now add all channels and put the sample to the buffer    


p101        cmp     oldt0,time0 wz   ' There must not be 2 entries with the same time
    if_z    sub     front,#2         ' 
    if_z    and     front,#511     
  
            mov     rs,#0            ' Mix all channels to rs and ls
            mov     ls,#0
            add     rs,rs1
            add     rs,rs2
            add     rs,rs3
            add     rs,rs4
            add     rs,rs5
            add     rs,rs6
            add     rs,rs7
            add     rs,rs8
            
            add     ls,ls1
            add     ls,ls2
            add     ls,ls3
            add     ls,ls4
            add     ls,ls5
            add     ls,ls6
            add     ls,ls7
            add     ls,ls8
 		
            bitnot  ls,#15            ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
            bitnot  rs,#15		      ' and these with $FFFF if a filter should be applied
		    
            setword rs,ls,#1         ' Pack L and R to one long    		
            mov newsample, rs

            mov     oldt0,time0      ' update global time
            add     time0,dt0     
            
                                     ' now push dt0 samples to the buffer
            cmp      dt0,#0 wz
    if_z    jmp      #loop1
            mov      t1,dt0
  
p301        mov     t2,ptrb         ' Check if the buffer is full	
            sub     t2,#1
            and     t2,#511
            cmp     t2,front wcz
    if_e    jmp     #p301    
    
            wrlut   newsample, front
            add     front,#1
            and     front,#511
            djnz    t1,#p301
            jmp     #loop            'loop

'-------------------------------------------------------------------------
'------------------ This is the end of the main loop ---------------------
'-------------------------------------------------------------------------

'--------------------------------------------------------------------------
'------ Interrupt service -------------------------------------------------
'------ Output the sample, get the next one if exists ---------------------
'--------------------------------------------------------------------------

isr1        wypin   lsample,#left        '2     The sample has to be outputted every 90 cycles     
            wypin   rsample,#right       '4
           
            cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
    if_e    reti1                        '8/10

            rdlut   lsnext,ptrb++        '11    else read the sample and its time from LUT
          	getword rsample,lsnext,#1    '13
          	getword lsample,lsnext,#0    '15
            reti1                        '17/19 
          
'---------------------------------------------------------------------------
'-------- End of interrupt -------------------------------------------------
'---------------------------------------------------------------------------    


'---------------------------------------------------------------------------
'------- Variables ---------------------------------------------------------
'---------------------------------------------------------------------------

' constants

a1fffffff long $1fffffff
a20000000 long $20000000
a21000000 long $21000000
newsample long 0
affff long $ffff
t1 long 0
t2 long 0
nl long 0
nr long 0
nrsample long 0
nlsample long 0
fl long 31
fr long 31
d long 0
' phase accumulators

p1          long 0
p2          long 0
p3          long 0
p4          long 0
p5          long 0
p6          long 0
p7          long 0
p8          long 0

' temporary variables 

qq          long 0
spl         long 0

' circular buffer in LUT

front       long 0
'tail        long 0

' Interrupt ISR variables

counter     long $FFFFF800 ' this counter will overflow after 1210 seconds
lsample     long 0
rsample     long 0
lsnext      long 0
rsnext      long 0 
irqtime     long 0

' Channel 1 registers. TODO - optimize the memory usage   ''' optimization: start pointer, loop start loop end long type bit cmd bytevol pan wordskip byte cmd bit
' sstart: long, 2 upper bits: type
' lstart, long 
' lend :long
' vol+pan long
' freq,skip :long    5 longs per chn instead of 9 = 80 longs for 16 chn + 16 PAs + 16 timers+ 32 samples = 144 longs
' cmd: 1 long for all

sstart1     long 0       ' Sample start pointer
type1       long 0       ' type 0 16 bit, 1 8 bit
lstart1     long 0       ' Loop start
lend1       long 2       ' Loop end
vol1        long 0       ' volume, 0..16384
apan1       long 0       ' pan, 0..16384
freq1       long 101     ' frequency divider
askip1      long 2       ' skip between samples, 1 for 8 bit, 2 for 16 bit (or more for special effects)
acmd1       long 0       ' command, 0 = reset the phase accumulator

' Channel 2 registers

sstart2     long 0
type2       long 0
lstart2     long 0
lend2       long 2        		
vol2        long 0
apan2       long 0
freq2       long 103
askip2      long 2
acmd2       long 0

' Channel 3 registers

sstart3     long 0
type3       long 0
lstart3     long 0
lend3       long 2       		'
vol3        long 0
apan3       long 0
freq3       long 107 '109 113 127 131 137 ...
askip3      long 2
acmd3       long 0

' Channel 4 registers

sstart4     long 0
type4       long 0
lstart4     long 0
lend4       long 2       		'
vol4        long 0
apan4       long 0
freq4       long 109 '109 113 127 131 137 ...
askip4      long 2
acmd4       long 0

' Channel 5 registers

sstart5     long 0
type5       long 0
lstart5     long 0
lend5       long 2       		'
vol5        long 0
apan5       long 0
freq5       long 113 '109 113 127 131 137 ...
askip5      long 2
acmd5       long 0

' Channel 6 registers

sstart6     long 0
type6       long 0
lstart6     long 0
lend6       long 2       		'
vol6        long 0
apan6       long 0
freq6       long 127 '109 113 127 131 137 ...
askip6      long 2
acmd6       long 0

' Channel 7 registers

sstart7     long 0
type7       long 0
lstart7     long 0
lend7       long 2       		'
vol7        long 0
apan7       long 0
freq7       long 131 '109 113 127 131 137 ...
askip7      long 2
acmd7       long 0

' Channel 8 registers

sstart8     long 0
type8       long 0
lstart8     long 0
lend8       long 2       		'
vol8        long 0
apan8       long 0
freq8       long 131 '109 113 127 131 137 ...
askip8      long 2
acmd8       long 0

' Time variables

time0       long 0    ' Global sample computing time
time1       long 1    ' Local channels time
time2       long 2
time3       long 3
time4       long 4
time5       long 5
time6       long 6
time7       long 7
time8       long 8

oldt0       long 0    'Temporary time variables
cn          long 0
ct          long 0
dt0         long 0

' Samples

ls          long 0    ' Global sample variable
rs          long 0

ls1         long 0    ' Channel samples
rs1         long 0
ls2         long 0
rs2         long 0
ls3         long 0
rs3         long 0
rs4         long 0
ls4         long 0
rs5         long 0
ls5         long 0
rs6         long 0
ls6         long 0
rs7         long 0
ls7         long 0
rs8         long 0
ls8         long 0

dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
'dac        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   

'-----------------------------------------------------------------------------------------
'------ PASM driver ends here ------------------------------------------------------------
'----------------------------------------------------------------------------------------- 

'
dat 

null  			long 	0,0           ' for channel reset
sinewave 		file 	"sinus.s2"    ' for testing
