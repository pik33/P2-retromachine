{
################################################################################################################################
#                             SIDcog - SID/MOS8580 emulator v1.4  (C) 2020 Johannes Ahlebrand                                  #
################################################################################################################################
#                                    TERMS OF USE: Parallax Object Exchange License                                            #
################################################################################################################################
#Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    #
#files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    #
#modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software#
#is furnished to do so, subject to the following conditions:                                                                   #
#                                                                                                                              #
#The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.#
#                                                                                                                              #
#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          #
#WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         #
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   #
#ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         #
################################################################################################################################


Revision History

v0.7 (December 2009)   - Initial release

v0.8 (February 2010)   - Added support for "combined waveforms"
                       - Optimized code
                       - Fixed bugs

v1.0 (May 2011)        - First OBEX release
                       - Added convenient API methods

v1.2 (August 2011)     - Increased ADSR accuracy  (Almost perfect now; The famous ADSR bug isn't implemented though)
                       - Increased Noise accuracy (As close as we will get without decreasing the sample rate of SIDcog)
                       - Fixed a bug when no waveform was selected
                       - Decreased the "max cutoff frequency" a bit to fix aliasing issues
                       - Made some small optimizations

v1.3 (April 2012)      - Fixed a bug when noise + any other waveform was selected at the same time
                       - Calibrated the cutoff frequency to better match a real 8580
                       - Cycle optimized code to "make room" for the point below --
                       - Increased resonance accuracy (replaced "4 step logaritmic lookup table" with "16 step bit linear multiplication")
                       - Increased ADSR accuracy a little bit more (the ADSR bug is still not implemented)

v1.3.P2 (Januari 2019) - "Tweeked" the SIDcog v1.3 P1 code to run as unmodified as possible on the P2
                       - NO improvements regarding audio quality or accuracy (still 31.25 kHz sample rate)
                       - NO improvements of using more optimized P2 instructions or LUT RAM or anything
                       - Still uses a subroutine for multiplication (that ate around half the cycles each sample on the P1)

v1.3.E1 (Januari 2019) - SIDcog now runs at a sample rate of ~250 kHz on a 80 MHz P2 (8 times higher than before) thanks to the points below
                       - Changed multiplication to hardware instructions
                       - Changed shift/mask instruction to getnib, getword, getbyte, rolbyte etc
                       - Changed hub access to fast "burst" mode by reading everything at once to cog memory

v1.4    (Januari 2020) - For the first time in the history if SIDcog, it has the exact same memory mapping as the real SID chip (no alignment paddings)
                       - Some small P2 optimizations
}

CON
_clkfreq=354_689_500


 PAL = 985248.0, NTSC = 1022727.0, MAXF = 1031000.0, TRIANGLE = 16, SAW = 32, SQUARE = 64, NOISE = 128

  L_PIN = 14
  R_PIN = 15

  SYSTEM_CLOCK         = 354_689_500
  C64_CLOCK_FREQ       = PAL
  '                                           ___
  RESONANCE_OFFSET     = 7'                     |
  RESONANCE_FACTOR     = 5'                     |
  'CUTOFF_LIMIT        = 1100'                  |
  LP_MAX_CUTOFF        = 14'                    | Don't alter these constants unless you know what you are doing!
  BP_MAX_CUTOFF        = 12'                    |
  FILTER_OFFSET        = 16'                    |
  START_LOG_LEVEL      = $5d5d5d5d'             |
  DECAY_DIVIDE_REF     = $6C6C6C6C'             |
  ENV_CAL_FACTOR       = 545014038.181330/8.0'  | ENV_CAL_FACTOR = (MaxUint32  / SIDcogSampleFreq) / (1 / SidADSR_1secRomValue)
  NOISE_ADD            = %1010_1010_101<<23'    | ENV_CAL_FACTOR = (4294967295 / 30789           ) / (1 / 3907                ) = 545014038,181330
  NOISE_TAP            = %100001 << 8'       ___|
  DAC_MODE             = %00010_0 ' DAC 16-bit dither, noise
  DIR_MODE             = %01      ' Output enabled, overrides DIR
  INIT_8BIT_DAC_VALUE  = 128
  ANALOG_OUT_MODE      = %10111 '  75 ohm, 2.0V DAC mode
  SMARTPIN_DAC_MODE    = (ANALOG_OUT_MODE << 16) | (INIT_8BIT_DAC_VALUE << 8) | (DIR_MODE << 6) | DAC_MODE
  SAMPLE_PERIOD        = 1440 ' SYSTEM_CLOCK / trunc(C64_CLOCK_FREQ / 2.0)  'clocks between samples

var
byte regs[25]
byte pad[3]
long SIDSample

pub demo()|cog , i,b ,dp

regs:=@regs
cog:= start()
dp:=@dumpfile
repeat
  repeat i from 0 to 24
    b:=byte[dp]
    regs[i]:=b
    dp++
  waitms(20)





pub start():cog

cog:=coginit(16,@SIDEMU,@regs )
return cog

dat
combinedWaveforms   file "combinedwaveforms.bin"

dat
dumpFile            file "plastic_pop.dmp"

DAT

               org
'----------------------------------------------------------------------------------------------------------------------
'                                          Assembly SID emulator
'----------------------------------------------------------------------------------------------------------------------
SIDEMU        wrpin   smartConfigAudioDAC, #L_PIN  addpins 1         ' Config smartpin DAC mode on left pin
              wxpin   samplePeriod, #L_PIN   addpins 1               ' Sample period for left audio channel
              dirh    #L_PIN    addpins 1                            ' Enable smartpin DAC mode on left pin
              setse1  #%001_000000 | L_PIN                           ' Event triggered every new sample period (when "left in pin rises")

'----------------------------------------------------------------------------------------------------------------------
' Read all SID-registers from hub memory and convert
' them to more convenient representations.
'----------------------------------------------------------------------------------------------------------------------
getRegisters  
                       
              setq      #7-1                                ' Number of longs, minus 1, to read
              rdlong    sidRegsCogCopy, ptra                ' Read 6 longs to cog address

'===========================================================
'              Extract channel 1 register data
'===========================================================
              getword   frequency1, sidRegsCogCopy, #0
              getword   pulseWidth1, sidRegsCogCopy, #1
              shl       pulseWidth1, #20                    ' Shift in "12 bit" pulse width value( make it 32 bits )
              shl       frequency1, #10
'-----------------------------------------------------------
              getnib    selectedWaveform1, sidRegsCogCopy + 1, #1
              mov       acontrolRegister1, sidRegsCogCopy + 1
'-----------------------------------------------------------
              getnib    r1, sidRegsCogCopy + 1, #2
              alts      r1, #ADSRTable
              mov       decay1, 0-0
              getnib    r1, sidRegsCogCopy + 1, #3
              alts      r1, #ADSRTable                      '|  Convert 4bit ADSR "presets" to their corresponding
              mov       attack1, 0-0                        '|  32bit values using the attack/decay table.
              getnib    r1, sidRegsCogCopy + 1, #4
              alts      r1, #ADSRTable
              mov       release1, 0-0
              getnib    r1, sidRegsCogCopy + 1, #5
              setnib    sustain1, r1, #7
              setnib    sustain1, r1, #6
'-----------------------------------------------------------
              test      acontrolRegister1, #1            wc
              cmp       envelopeState1, #2              wz
 if_z_and_c   mov       envelopeState1, #0
 if_nz_and_nc mov       envelopeState1, #2
'===========================================================
'              Extract channel 2 register data
'===========================================================
              getbyte   frequency2, sidRegsCogCopy + 2, #0
              rolbyte   frequency2, sidRegsCogCopy + 1, #3
              mov       pulseWidth2, sidRegsCogCopy + 2
              shr       pulseWidth2, #8
              zerox     pulseWidth2, #15
              shl       pulseWidth2, #20                    ' Shift in "12 bit" pulse width value( make it 32 bits )
              shl       frequency2,  #10
'-----------------------------------------------------------
              getnib    selectedWaveform2, sidRegsCogCopy + 2, #7
              getbyte   acontrolRegister2,  sidRegsCogCopy + 2, #3
'-----------------------------------------------------------
              getnib    r1, sidRegsCogCopy + 3, #0
              alts      r1, #ADSRTable
              mov       decay2, 0-0
              getnib    r1, sidRegsCogCopy + 3, #1
              alts      r1, #ADSRTable                      '|  Convert 4bit ADSR "presets" to their corresponding
              mov       attack2, 0-0                          '|  32bit values using attack/decay tables.
              getnib    r1, sidRegsCogCopy + 3, #2
              alts      r1, #ADSRTable
              mov       release2, 0-0
              getnib    r1, sidRegsCogCopy + 3, #3
              setnib    sustain2, r1, #7
              setnib    sustain2, r1, #6
'-----------------------------------------------------------
              test      acontrolRegister2, #1            wc
              cmp       envelopeState2, #2              wz
 if_z_and_c   mov       envelopeState2, #0
 if_nz_and_nc mov       envelopeState2, #2
'===========================================================
'              Extract channel 3 register data
'===========================================================
              getword   frequency3, sidRegsCogCopy + 3, #1
              getword   pulseWidth3, sidRegsCogCopy + 4, #0
              shl       pulseWidth3, #20                    ' Shift in "12 bit" pulse width value( make it 32 bits )
              shl       frequency3, #10
'-----------------------------------------------------------
              getnib    selectedWaveform3, sidRegsCogCopy + 4, #5
              getbyte   acontrolRegister3,  sidRegsCogCopy + 4, #2
'-----------------------------------------------------------
              getnib    r1, sidRegsCogCopy + 4, #6
              alts      r1, #ADSRTable
              mov       decay3, 0-0
              getnib    r1, sidRegsCogCopy + 4, #7
              alts      r1, #ADSRTable                      '|  Convert 4bit ADSR "presets" to their corresponding
              mov       attack3, 0-0                          '|  32bit values using attack/decay tables.
              getnib    r1, sidRegsCogCopy + 5, #0
              alts      r1, #ADSRTable
              mov       release3, 0-0
              getnib    r1, sidRegsCogCopy + 5, #1
              setnib    sustain3, r1, #7
              setnib    sustain3, r1, #6
'-----------------------------------------------------------
              test      acontrolRegister3, #1            wc
              cmp       envelopeState3, #2              wz
 if_z_and_c   mov       envelopeState3, #0
 if_nz_and_nc mov       envelopeState3, #2
'===========================================================
'            Extract filter/volume register data
'===========================================================
              getbyte   filterCutoff, sidRegsCogCopy + 5, #2
              shl       filterCutoff, #2
              add       filterCutoff, filterOffset
              getnib    filterControl, sidRegsCogCopy + 5, #6
              getnib    filterResonance, sidRegsCogCopy + 5, #7
              getnib    volume, sidRegsCogCopy + 6, #0
              getnib    filterMode, sidRegsCogCopy + 6, #1


'----------------------------------------------------------------------------------------------------------------------
' Calculate sid samples channel 1 - 3 and store in out1 - out3
'----------------------------------------------------------------------------------------------------------------------
'===========================================================
'    Increment phase accumulator 1 - 3 and handle syncing
'===========================================================
              add      phaseAccumulator1, frequency1    wc ' Add frequency value to phase accumulator 1
  if_nc       andn     acontrolRegister2, #2
              test     acontrolRegister2, #10            wz ' Sync oscilator 2 to oscillator 1 if sync = on
  if_nz       mov      phaseAccumulator2, #0               ' Or reset oscilator 2 when bit 4 of control register is 1
'-----------------------------------------------------------
              add      phaseAccumulator2, frequency2    wc
  if_nc       andn     acontrolRegister3, #2
              test     acontrolRegister3, #10            wz ' Sync oscilator 3 to oscillator 2 if sync = on
  if_nz       mov      phaseAccumulator3, #0               ' Or reset oscilator 3 when bit 4 of control register is 1
'-----------------------------------------------------------
              add      phaseAccumulator3, frequency3    wc
  if_nc       andn     acontrolRegister1, #2
              test     acontrolRegister1, #10            wz ' Sync oscilator 1 to oscillator 3 if sync = on
  if_nz       mov      phaseAccumulator1, #0               ' Or reset oscilator 1 when bit 4 of control register is 1

'===========================================================
'            Waveform shaping channel 1 -> arg1
'===========================================================
Saw1          cmp      selectedWaveform1, #2            wz
              mov      arg1, phaseAccumulator1
  if_z        jmp      #Envelope1
'-----------------------------------------------------------
Triangle1     cmp      selectedWaveform1, #1            wcz
  if_nz       jmp      #Square1
              shl      arg1, #1                         wc
  if_c        xor      arg1, mask32bit
              test     acontrolRegister1, #4             wz '|
  if_nz       testb     phaseAccumulator3, #31      wz '| These 3 lines handles ring modulation
  if_nz       xor      arg1, mask32bit                     '|
              jmp      #Envelope1
'-----------------------------------------------------------
Square1       cmp      selectedWaveform1, #4            wz
  if_z        sub      pulseWidth1, phaseAccumulator1   wc
  if_z        muxc     arg1, mask32bit
  if_z        jmp      #Envelope1
'-----------------------------------------------------------
Noise1        cmp      selectedWaveform1, #8            wz
  if_nz       jmp      #Combined1
              and      arg1, mask28bit
              sub      arg1, frequency1                 wc
              mov      arg1, noiseValue1
              add      arg1, noiseAddValue
  if_nc       jmp      #Envelope1
              test     noiseValue1, noiseTap            wc
              rcr      noiseValue1, #1
              'getrnd   noiseValue1
              jmp      #Envelope1
'-----------------------------------------------------------
Combined1     test     selectedWaveform1, #8            wz
              sub      selectedWaveform1, #4
              fges     selectedWaveform1, #0
              shl      selectedWaveform1, #8
              mov      tempValue, phaseAccumulator1
              shr      tempValue, #24
              add      selectedWaveform1, tempValue
              add      selectedWaveform1, combTableAddr
              mov      arg1,#128
  if_nc_and_z rdbyte   arg1, selectedWaveform1
              shl      arg1, #24

'===========================================================
'            Envelope shaping channel 1 -> arg2
'===========================================================
Envelope1     mov      tempValue, decayDivideRef
              shr      tempValue, decayDivide1
              cmp      envelopeLevel1, tempValue        wc
              tjnz     envelopeState1, #Env_Dec1
'-----------------------------------------------------------
Env_At1 if_nc cmpsub   decayDivide1, #1
              add      envelopeLevel1, attack1          wc
  if_c        mov      envelopeLevel1, mask32bit
  if_c        mov      envelopeState1, #1
              jmp      #Amplitude1
'-----------------------------------------------------------
Env_Dec1 if_c add      decayDivide1, #1
              cmp      startLogLevel, envelopeLevel1    wc
              cmp      envelopeState1, #1               wz
  if_nz       jmp      #Rel1
  if_nc       shr      decay1, decayDivide1
              sub      envelopeLevel1, decay1
              fge      envelopeLevel1, sustain1         wc
              jmp      #Amplitude1
'-----------------------------------------------------------
Rel1 if_nc    shr      release1, decayDivide1
              cmpsub   envelopeLevel1, release1
'===========================================================
'Calculate sample out1 = arg1 * arg2 (waveform * amplitude)
'===========================================================
Amplitude1    shr      arg1, #14
              sub      arg1, val15bit
              mov      arg2, envelopeLevel1
              shr      arg2, #24
              call #multiply

              mov      out1, r1
'===========================================================
'            Waveform shaping channel 2 -> arg1
'===========================================================
Saw2          cmp      selectedWaveform2, #2            wz
              mov      arg1, phaseAccumulator2
  if_z        jmp      #Envelope2
'-----------------------------------------------------------
Triangle2     cmp      selectedWaveform2, #1            wcz
  if_nz       jmp      #Square2
              shl      arg1, #1                         wc
  if_c        xor      arg1, mask32bit
              test     acontrolRegister2, #4             wz '|
  if_nz       testb     phaseAccumulator1, #31      wz '| These 3 lines handles ring modulation
  if_nz       xor      arg1, mask32bit                     '|
              jmp      #Envelope2
'-----------------------------------------------------------
Square2       cmp      selectedWaveform2, #4            wz
  if_z        sub      pulseWidth2, phaseAccumulator2   wc ' C holds the pulse width modulated square wave
  if_z        muxc     arg1, mask32bit
  if_z        jmp      #Envelope2
'-----------------------------------------------------------
Noise2        cmp      selectedWaveform2, #8            wz
  if_nz       jmp      #Combined2
              and      arg1, mask28bit
              sub      arg1, frequency2                 wc
              mov      arg1, noiseValue2
              add      arg1, noiseAddValue
  if_nc       jmp      #Envelope2 
              test     noiseValue2, noiseTap            wc
              rcr      noiseValue2, #1
              'getrnd   noiseValue2
              jmp      #Envelope2
'-----------------------------------------------------------
Combined2     test     selectedWaveform2, #8            wz
              sub      selectedWaveform2, #4
              fges     selectedWaveform2, #0
              shl      selectedWaveform2, #8
              mov      tempValue, phaseAccumulator2
              shr      tempValue, #24
              add      selectedWaveform2, tempValue
              add      selectedWaveform2, combTableAddr
              mov      arg1,#128
  if_nc_and_z rdbyte   arg1, selectedWaveform2
              shl      arg1, #24
'===========================================================
'            Envelope shaping channel 2 -> arg2
'===========================================================
Envelope2     mov      tempValue, decayDivideRef
              shr      tempValue, decayDivide2
              cmp      envelopeLevel2, tempValue        wc
              tjnz     envelopeState2, #Env_Dec2
'-----------------------------------------------------------
Env_At2 if_nc cmpsub   decayDivide2, #1
              add      envelopeLevel2, attack2          wc
  if_c        mov      envelopeLevel2, mask32bit
  if_c        mov      envelopeState2, #1
              jmp      #Amplitude2
'-----------------------------------------------------------
Env_Dec2 if_c add      decayDivide2, #1
              cmp      startLogLevel,envelopeLevel2     wc
              cmp      envelopeState2, #1               wz
  if_nz       jmp      #Rel2
  if_nc       shr      decay2, decayDivide2
              sub      envelopeLevel2, decay2
              fge      envelopeLevel2, sustain2         wc
              jmp      #Amplitude2
'-----------------------------------------------------------
Rel2 if_nc    shr      release2, decayDivide2
              cmpsub   envelopeLevel2, release2
'===========================================================
'Calculate sample out2 = arg1 * arg2 (waveform * amplitude)
'===========================================================
Amplitude2    shr      arg1, #14
              sub      arg1, val17bit
              mov      arg2, envelopeLevel2
              shr      arg2, #24
              call     #multiply
              mov      out2, r1
'===========================================================
'            Waveform shaping channel 3 -> arg1
'===========================================================
Saw3          cmp      selectedWaveform3, #2            wz
              mov      arg1, phaseAccumulator3
  if_z        jmp      #Envelope3
'-----------------------------------------------------------
Triangle3     cmp      selectedWaveform3, #1            wcz
  if_nz       jmp      #Square3
              shl      arg1, #1                         wc
  if_c        xor      arg1, mask32bit
              test     acontrolRegister3, #4             wz '|
  if_nz       testb     phaseAccumulator2, #31      wz '| These 3 lines handles ring modulation
  if_nz       xor      arg1, mask32bit                     '|
              jmp      #Envelope3
'-----------------------------------------------------------
Square3       cmp      selectedWaveform3, #4            wz
  if_z        sub      pulseWidth3, phaseAccumulator3   wc ' C holds the pulse width modulated square wave
  if_z        muxc     arg1, mask32bit
  if_z        jmp      #Envelope3
'-----------------------------------------------------------
Noise3        cmp      selectedWaveform3, #8            wz 
  if_nz       jmp      #Combined3  
              and      arg1, mask28bit
              sub      arg1, frequency3                 wc
              mov      arg1, noiseValue3
              add      arg1, noiseAddValue
  if_nc       jmp      #Envelope3 
              test     noiseValue3, noiseTap            wc 
              rcr      noiseValue3, #1 
              'getrnd   noiseValue3
              jmp      #Envelope3
'-----------------------------------------------------------
Combined3     test     selectedWaveform3, #8            wz
              sub      selectedWaveform3, #4
              fges     selectedWaveform3, #0
              shl      selectedWaveform3, #8
              mov      tempValue, phaseAccumulator3
              shr      tempValue, #24
              add      selectedWaveform3, tempValue
              add      selectedWaveform3, combTableAddr
              mov      arg1,#128
  if_nc_and_z rdbyte   arg1, selectedWaveform3
              shl      arg1, #24
'===========================================================
'            Envelope shaping channel 3 -> arg2
'===========================================================
Envelope3     mov      tempValue, decayDivideRef
              shr      tempValue, decayDivide3
              cmp      envelopeLevel3, tempValue        wc
              tjnz     envelopeState3, #Env_Dec3
'-----------------------------------------------------------
Env_At3 if_nc cmpsub   decayDivide3, #1
              add      envelopeLevel3, attack3          wc
  if_c        mov      envelopeLevel3, mask32bit
  if_c        mov      envelopeState3, #1
              jmp      #Amplitude3
'-----------------------------------------------------------
Env_Dec3 if_c add      decayDivide3, #1
              cmp      startLogLevel, envelopeLevel3    wc
              cmp      envelopeState3, #1               wz
  if_nz       jmp      #Rel3
  if_nc       shr      decay3, decayDivide3
              sub      envelopeLevel3, decay3
              fge      envelopeLevel3, sustain3         wc
              jmp      #Amplitude3
'-----------------------------------------------------------
Rel3 if_nc    shr      release3, decayDivide3
              cmpsub   envelopeLevel3, release3
'===========================================================
'Calculate sample out3 = arg1 * arg2 (waveform * amplitude)
'===========================================================
Amplitude3    shr      arg1, #14
              sub      arg1, val17bit
              mov      arg2, envelopeLevel3
              shr      arg2, #24
              call     #multiply

              mov      out3, r1

'===========================================================
'              Handle multi-mode filtering
'===========================================================
filter        mov      highPassFilter1, out1                  '|
              mov      highPassFilter2, out2         
              mov      highPassFilter3, out3        
  
'-----------------------------------------------------------
              mov      arg2, filterResonance               '|
              add      arg2, #RESONANCE_OFFSET             '|
              mov      arg1, bandPassFilter1                '|
              sar      arg1, #RESONANCE_FACTOR             '|
              call     #multiply                           '| High pass filter
              sub      highPassFilter1, bandPassFilter1      '|
              add      highPassFilter1, r1                  '|
              sub      highPassFilter1, lowPassFilter1       '|
'-----------------------------------------------------------
              mov      arg1, highPassFilter1                '|
              sar      arg1, #BP_MAX_CUTOFF                '|
              mov      arg2, filterCutoff                  '| Band pass filter
              call     #multiply                           '|
              add      bandPassFilter1, r1                  '|
'-----------------------------------------------------------
              mov      arg1, bandPassFilter1                '|
              sar      arg1, #LP_MAX_CUTOFF                '|
              mov      arg2, filterCutoff                  '| Low pass filter
              call     #multiply                           '|
              add      lowPassFilter1, r1                   '|
              
'-----------------------------------------------------------

              
  
'-----------------------------------------------------------
              mov      arg2, filterResonance               '|
              add      arg2, #RESONANCE_OFFSET             '|
              mov      arg1, bandPassFilter2                '|
              sar      arg1, #RESONANCE_FACTOR             '|
              call     #multiply                           '| High pass filter
              sub      highPassFilter2, bandPassFilter2      '|
              add      highPassFilter2, r1                  '|
              sub      highPassFilter2, lowPassFilter2       '|
'-----------------------------------------------------------
              mov      arg1, highPassFilter2                '|
              sar      arg1, #BP_MAX_CUTOFF                '|
              mov      arg2, filterCutoff                  '| Band pass filter
              call     #multiply                           '|
              add      bandPassFilter2, r1                  '|
'-----------------------------------------------------------
              mov      arg1, bandPassFilter2                '|
              sar      arg1, #LP_MAX_CUTOFF                '|
              mov      arg2, filterCutoff                  '| Low pass filter
              call     #multiply                           '|
              add      lowPassFilter2, r1                   '|
              
'-----------------------------------------------------------

              
  
'-----------------------------------------------------------
              mov      arg2, filterResonance               '|
              add      arg2, #RESONANCE_OFFSET             '|
              mov      arg1, bandPassFilter3                '|
              sar      arg1, #RESONANCE_FACTOR             '|
              call     #multiply                           '| High pass filter
              sub      highPassFilter3, bandPassFilter3      '|
              add      highPassFilter3, r1                  '|
              sub      highPassFilter3, lowPassFilter3       '|
'-----------------------------------------------------------
              mov      arg1, highPassFilter3                '|
              sar      arg1, #BP_MAX_CUTOFF                '|
              mov      arg2, filterCutoff                  '| Band pass filter
              call     #multiply                           '|
              add      bandPassFilter3, r1                  '|
'-----------------------------------------------------------
              mov      arg1, bandPassFilter3                '|
              sar      arg1, #LP_MAX_CUTOFF                '|
              mov      arg2, filterCutoff                  '| Low pass filter
              call     #multiply                           '|
              add      lowPassFilter3, r1                   '|
              
'-----------------------------------------------------------
         
              
              
'-----------------------------------------------------------
              mov      filterOutput1, #0   
              mov      filterOutput2, #0                
              mov      filterOutput3, #0                               '|
              test     filterMode, #1            wc        '|
  if_c        add      filterOutput1, lowPassFilter1         '|
  if_c        add      filterOutput2, lowPassFilter2         '|
  if_c        add      filterOutput3, lowPassFilter3         '|

              test     filterMode, #2            wc        '| Enable/Disable
  if_c        add      filterOutput1, bandPassFilter1        '| Low/Band/High pass filtering
  if_c        add      filterOutput2, bandPassFilter2    
  if_c        add      filterOutput3, bandPassFilter3 
              test     filterMode, #4            wc        '|
  if_c        add      filterOutput1, highPassFilter1       '|
  if_c        add      filterOutput2, highPassFilter2       '|
  if_c        add      filterOutput3, highPassFilter3     
   '|



              test     filterControl, #1                wc '|
  if_c        mov      out1,filteroutput1               '| 
              test     filterControl, #2                wc '| Route channels trough the filter
  if_c        mov      out2,filteroutput2                 '| or bypass them
              test     filterControl, #4                wc '|
  if_c        mov      out3,filteroutput3               '|

  


'----------------------------------------------------------------------------------------------------------------------
'      Mix channels and update FRQA/FRQB PWM-values
'----------------------------------------------------------------------------------------------------------------------
mixer         mov      arg1, out3
              sar      arg1, #1
              add      arg1, out1
              mov      arg2,out1
              sar      arg2,#1
              add      arg1,arg2
              add      arg1, out2
              
'-----------------------------------------------------------
              fles     arg1, clipLevelHigh                 '|
              fges     arg1, clipLevelLow                  '|
              mov      arg2, volume                        '|
              call     #multiply                           '|
'-----------------------------------------------------------
            bitnot r1,#31                   '  DC offset
'-----------------------------------------------------------
              shr      r1, #16
              wypin    r1, #L_PIN                          ' Output sample on left channel
 
 mov          arg1,     out1
              sar      arg1, #1
              add      arg1, out3
              mov      arg2, out3
              sar      arg2, #1
              add      arg1, arg2
              add      arg1, out2
              
'-----------------------------------------------------------
              fles     arg1, clipLevelHigh                 '|
              fges     arg1, clipLevelLow                  '|
              mov      arg2, volume                        '|
              call     #multiply                           '|

'-----------------------------------------------------------
                 bitnot r1,#31                      '  DC offset
'-----------------------------------------------------------
              shr      r1, #16
              wypin    r1, #R_PIN                          ' Output sample on right channel


              waitse1
'-----------------------------------------------------------
              mov      tempValue, ptra
              add      tempValue, #28
              wrlong   r1, tempValue                       '| Write the sample to hub ram
              jmp      #getRegisters

'---------------------------------------------------------------------------------------------------------------------- 
'    Multiplication     r1(I32) = arg1(I32) * arg2(I32)
'----------------------------------------------------------------------------------------------------------------------
multiply      getword  r1,arg1,#1
              mul      r1, arg2
              shl      r1, #16
              mul      arg1, arg2
    _ret_     add      r1, arg1



'----------------------------------------------------------------------------------------------------------------------
'    Variables, tables, masks and reference values
'----------------------------------------------------------------------------------------------------------------------
ADSRTable           long trunc(ENV_CAL_FACTOR * (1.0 / 9.0    )) '2   ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 32.0   )) '8   ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 63.0   )) '16  ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 95.0   )) '24  ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 149.0  )) '38  ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 220.0  )) '56  ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 267.0  )) '68  ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 313.0  )) '80  ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 392.0  )) '100 ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 977.0  )) '250 ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 1954.0 )) '500 ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 3126.0 )) '800 ms
                    long trunc(ENV_CAL_FACTOR * (1.0 / 3907.0 )) '1   s
                    long trunc(ENV_CAL_FACTOR * (1.0 / 11720.0)) '3   s
                    long trunc(ENV_CAL_FACTOR * (1.0 / 19532.0)) '5   s
                    long trunc(ENV_CAL_FACTOR * (1.0 / 31251.0)) '8   s

'Masks and reference values
startLogLevel       long START_LOG_LEVEL
sustainAdd          long $0f000000
mask32bit           long $ffffffff
mask28bit           long $fffffff
'val31bit            long $80000000
val17bit            long $20000
val15bit            long $8000
clipLevelHigh       long $8000000
clipLevelLow        long-$8000000
filterOffset        long FILTER_OFFSET
decayDivideRef      long DECAY_DIVIDE_REF
'maxCutoff           long CUTOFF_LIMIT
combTableAddr       long $1000
'par                 long @ch1_frequencyLo
samplePeriod        long SAMPLE_PERIOD                 'clocks between samples ( ~31.250 khz )
smartConfigAudioDAC long SMARTPIN_DAC_MODE

'Setup and subroutine parameters
arg1                long 1
arg2                long 1
r1                  long 1

'Sid variables
noiseAddValue       long NOISE_ADD
noiseTap            long NOISE_TAP
noiseValue1         long $ffffff
noiseValue2         long $ffffff
noiseValue3         long $ffffff
decayDivide1        long 0
decayDivide2        long 0
decayDivide3        long 0
envelopeLevel1      long  1
envelopeLevel2      long  1
envelopeLevel3      long  1
acontrolRegister1    long  1
acontrolRegister2    long  1
acontrolRegister3    long  1
frequency1          long  1
frequency2          long  1
frequency3          long  1
phaseAccumulator1   long  1
phaseAccumulator2   long  1
phaseAccumulator3   long  1
pulseWidth1         long  1
pulseWidth2         long  1
pulseWidth3         long  1
selectedWaveform1   long  1
selectedWaveform2   long  1
selectedWaveform3   long  1
envelopeState1      long  1
envelopeState2      long  1
envelopeState3      long  1
attack1             long  1
attack2             long  1
attack3             long  1
decay1              long  1
decay2              long  1
decay3              long  1
sustain1            long  1
sustain2            long  1
sustain3            long  1
release1            long  1
release2            long  1
release3            long  1
out1                long  1
out2                long  1
out3                long  1
filterResonance     long  1
filterCutoff        long  1
highPassFilter1      long  1
bandPassFilter1      long  1
lowPassFilter1      long  1
highPassFilter2      long  1
bandPassFilter2      long  1
lowPassFilter2       long  1
highPassFilter3      long  1
bandPassFilter3      long  1
lowPassFilter3      long  1
filterMode          long  1
filterControl       long  1
filterOutput1        long  1
filterOutput2       long  1
filterOutput3       long  1
volume              long  1
ordinaryOutput1      long  1
ordinaryOutput2      long  1
ordinaryOutput3      long  1

'Working variables
tempValue           long  1
sidRegsCogCopy      long 0,0,0,0,0,0,0

                    fit 497

{{
byte ch1_frequencyLo
byte ch1_frequencyHi
byte ch1_pulseWidthLo
byte ch1_pulseWidthHi
byte ch1_controlRegister
byte ch1_attackDecay
byte ch1_sustainRelease
byte ch2_frequencyLo
byte ch2_frequencyHi
byte ch2_pulseWidthLo
byte ch2_pulseWidthHi
byte ch2_controlRegister
byte ch2_attackDecay
byte ch2_sustainRelease
byte ch3_frequencyLo
byte ch3_frequencyHi
byte ch3_pulseWidthLo
byte ch3_pulseWidthHi
byte ch3_controlRegister
byte ch3_attackDecay
byte ch3_sustainRelease
byte Filter_cutoffLo
byte Filter_cutoffHi
byte Filter_reso_routing
byte Filter_mode_volume   }}
