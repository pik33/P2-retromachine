' A Paula inspired sample based synthesizer/audio driver for a P2
' v. 0.23 alpha - 20220131
' MIT license
' Piotr Kardasz pik33@o2.pl with the help from P2 forum community :) 
' 32 16-bit channels now and no more channel mixer :)
'-------------------------------------------------------------------
con

'319220550    =3546895, change to NTSC freq if needed
' 302672109 if 256/3, too low
' 36320665 if 512/5, too high...
'322159050 ' This is 90x Amiga NTSC = 3579545
_clkfreq = 354693878  ' This is 100x Amiga PAL 3546895
' audio pins TODO: make a variable for start() instead of const

left= 8
right=9

var

'channel+0  long current spl pointer - bit31=1 when 8bit spl
'channel+4  long sample
'channel+8  long sample start 
'channel+12 long loop start
'channel+16 long loop end
'channel+20 word volume
'channel+22 word pan
'channel+24 word synthfreq
'channel+26 word skip
'channel+28 long reserved
'

long channel1[8]
long channel2[8]
long channel3[8]
long channel4[8]
long channel5[8]
long channel6[8]
long channel7[8]
long channel8[8]
long channel9[8]
long channel10[8]
long channel11[8]
long channel12[8]
long channel13[8]
long channel14[8]
long channel15[8]
long channel16[8]
long channel17[8]
long channel18[8]
long channel19[8]
long channel20[8]
long channel21[8]
long channel22[8]
long channel23[8]
long channel24[8]
long channel25[8]
long channel26[8]
long channel27[8]
long channel28[8]
long channel29[8]
long channel30[8]
long channel31[8]
long channel32[8]

'--------------------------------------------------------------
'---------- Init the variables, start the cog. ----------------
'--------------------------------------------------------------

pub start() :cog,base | iii

base:=@channel1[0]

repeat iii from 0 to 31
  long[base+32*iii]:=0
  long[base+32*iii+4]:=0
  long[base+32*iii+12]:=0
  long[base+32*iii+16]:=2 
  word[base+32*iii+20]:=0
  word[base+32*iii+22]:=8192
  word[base+32*iii+24]:=400+2*iii
  word[base+32*iii+26]:=2
  long [base+32*iii+8]:=@null | $C0000000
  
cog:=coginit(16,@audio,@channel1)
waitms(100)
return cog,base

'--------------------------------------------------------------
'------ PASM driver code --------------------------------------
'-------------------------------------------------------------- 

dat

audio       org     0
            mov     ptrb,#0             ' A tail pointer for the buffer
            wrpin   dac,#left           ' Noise dither DACs at clk/100
            wxpin   #100,#left       
            wrpin   dac,#right
            wxpin   #100,#right    
            dirh    #left addpins 1
            setse1  #%001<<6 + left     ' Set the event - DAC empty
            mov     ijmp1,#isr1         ' Init the interrupt
            setint1 #4                  ' Interrupt from DAC empty event
            
'---------------------------------------------------------------------------------        
'----------------- The main loop -------------------------------------------------
'---------------------------------------------------------------------------------

loop        cmp     time0,a41000000 wc  ' time counter overflow protection
      if_c  jmp     #loop1
  
            mov     cn,#33             ' Substract $40000000 from all the channel times and the main timer
p402        altd    cn,#a41000000       ' this has to be done at once
            sub     0-0,a40000000
            djnz    cn,#p402
    
loop1       mov     cn,#0               ' Find the channel to compute
            mov     ct,time1            ' with the lowest next sample time
            fle     ct,time2 wcz        ' How to size-optimize this???
    if_c    mov     cn,#1
            fle     ct,time3 wcz
    if_c    mov     cn,#2     
            fle     ct,time4 wcz
    if_c    mov     cn,#3
            fle     ct,time5 wcz
    if_c    mov     cn,#4
            fle     ct,time6 wcz
    if_c    mov     cn,#5
            fle     ct,time7 wcz
    if_c    mov     cn,#6
            fle     ct,time8 wcz
    if_c    mov     cn,#7
            fle     ct,time9 wcz
    if_c    mov     cn,#8
            fle     ct,time10 wcz
    if_c    mov     cn,#9
            fle     ct,time11 wcz
    if_c    mov     cn,#10
            fle     ct,time12 wcz
    if_c    mov     cn,#11
            fle     ct,time13 wcz
    if_c    mov     cn,#12
            fle     ct,time14 wcz
    if_c    mov     cn,#13
            fle     ct,time15 wcz
    if_c    mov     cn,#14
            fle     ct,time16 wcz
    if_c    mov     cn,#15
            fle     ct,time17 wcz
    if_c    mov     cn,#16
            fle     ct,time18 wcz
    if_c    mov     cn,#17
            fle     ct,time19 wcz
    if_c    mov     cn,#18
            fle     ct,time20 wcz
    if_c    mov     cn,#19
            fle     ct,time21 wcz
    if_c    mov     cn,#20
            fle     ct,time22 wcz
    if_c    mov     cn,#21
            fle     ct,time23 wcz
    if_c    mov     cn,#22
            fle     ct,time24 wcz
    if_c    mov     cn,#23
            fle     ct,time25 wcz
    if_c    mov     cn,#24
            fle     ct,time26 wcz
    if_c    mov     cn,#25
            fle     ct,time27 wcz
    if_c    mov     cn,#26
            fle     ct,time28 wcz
    if_c    mov     cn,#27
            fle     ct,time29 wcz
    if_c    mov     cn,#28
            fle     ct,time30 wcz
    if_c    mov     cn,#29
            fle     ct,time31 wcz
    if_c    mov     cn,#30
            fle     ct,time32 wcz
    if_c    mov     cn,#31



'----------------------------------------------------------------------------------
'------------- Compute channel samples --------------------------------------------
'----------------------------------------------------------------------------------


p401        mov     channeladd,cn             ' compute the pointer to channel parameters block
            shl     channeladd,#5
            add     ptra,channeladd

            setq    #7                        ' read parameters
            rdlong  pointer0,ptra
            
            getword oldls,sample0,#0          ' extract old sample value
            getword oldrs,sample0,#1
     	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
    	    getword avol0,volpan0,#0
	    getword askip0,freqskip0,#1    	    
	    getword afreq0,freqskip0,#0

            alts    cn, #time1                ' compute the time difference between this and previous sample
            mov     dt0,0-0    
            sub     dt0,time0
            
            altd    cn, #time1                ' add channel period to channel time
            add     0-0,afreq0  	

            add     pointer0,askip0           ' compute the pointer to the next sample       
            cmp     pointer0,lend0 wcz
    if_ge   sub     pointer0,lend0	      ' and loop if needed     
    if_ge   add     pointer0,lstart0       
            mov     qq,pointer0               ' compute place in the hub memory from where the sample will be loaded
            add     qq,sstart0

            testb   sstart0,#31 wz            ' if bit #31 set, this is 16 bit sample, else it is 8 bit

    if_nz   rdbyte  spl,qq                    ' 8 bit, read and shifr
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq                    ' 16 bit, only read

            scas    spl,avol0                 ' apply volume
            mov     spl,0-0
 
            scas    spl,apan0                 ' apply pan
            mov     ls0,0-0
            mov     qq,##16384
            sub     qq,apan0
            scas    spl,qq
            mov     rs0, 0-0

            sub     rs,oldrs 		      ' replace the old sample with the new one in the mix
            add     rs,rs0
            sub     ls,oldls
            add     ls,ls0
   
            setword sample0,rs0,#1           ' pack samples into long
            setword sample0,ls0,#0
            
            bitl   sstart0, #30 wcz          ' if bit #30 of start pointer is set, the current pointer needs resetting  
    if_z    mov    pointer0, #0  
    if_z    wrlong sstart0, ptra[2]          ' reset bit #30 in hub

p403        setq #1                          ' write new pointer and sample value to the hub
            wrlong  pointer0,ptra
            sub     ptra, channeladd         ' reset the pointer to channel parameters
                      
            cmp     oldt0,time0 wz           '  If more than 1 sample is computed at the same time, write only the last result
    if_z    decmod  front, #511          
         
            mov     oldls,ls                 ' reuse oldls variable to convert the sample to unsigned
 	    mov     oldrs,rs
            bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
            bitnot  oldrs,#15		         ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
		    
            setword oldrs,oldls,#1           ' Pack L and R to one long    		
            mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
            mov     newsample, oldrs       

            mov     oldt0,time0               ' update global time
            add     time0,dt0    
                                     
            cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
    if_z    jmp     #loop1
            mov     qq,dt0
  
p301        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
            cmpr    front, #0-0 wcz
    if_e    jmp     #p301    
			    
            wrlut   oldsample, front         ' if there is a free slot, put the sample into the buffer
            incmod  front, ##511
            djnz    qq,#p301
            
            jmp     #loop            'loop

'-------------------------------------------------------------------------
'------------------ This is the end of the main loop ---------------------
'-------------------------------------------------------------------------

'--------------------------------------------------------------------------
'------ Interrupt service -------------------------------------------------
'------ Output the sample, get the next one if exists ---------------------
'--------------------------------------------------------------------------

isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
            wypin   rsample,#right       '4
            cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
    if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
    if_ne   incmod  ptrb,#511
    if_ne   getword rsample,lsnext,#1    '13
    if_ne   getword lsample,lsnext,#0    '15
            reti1                        '17/19 
          
'---------------------------------------------------------------------------
'-------- End of interrupt -------------------------------------------------
'---------------------------------------------------------------------------    


'---------------------------------------------------------------------------
'------- Variables ---------------------------------------------------------
'---------------------------------------------------------------------------

' constants

a40000000   long $40000000
a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before

' Time variables

time0       long 0    ' Global sample computing time
time1       long 1    ' Local channels time
time2       long 2
time3       long 3
time4       long 4
time5       long 5
time6       long 6
time7       long 7
time8       long 8
time9       long 9
time10      long 10
time11      long 11
time12      long 12
time13      long 13
time14      long 14
time15      long 15
time16      long 16
time17      long 17
time18      long 18
time19      long 19
time20      long 20
time21      long 21
time22      long 22
time23      long 23
time24      long 24
time25      long 25
time26      long 26
time27      long 27
time28      long 28
time29      long 29
time30      long 30
time31      long 31
time32      long 32




channeladd long 0

front       long 0

' temporary variables 
 
qq          long 0
spl         long 0

' Interrupt ISR variables

lsample     long 0
rsample     long 0
lsnext      long 0
rsnext      long 0 

' channel parameter block

pointer0    long 0     
sample0     long 0
sstart0     long 0     ' start pointer and type at bit 31
lstart0     long 0
lend0       long 0
volpan0     long 0
freqskip0   long 0
ctime0      long 0

afreq0      long 0
askip0      long 0
avol0       long 0
apan0       long 0

oldt0       long $FFFFFFFF    'Temporary time variables
cn          long 0
ct          long 0
dt0         long 0

' Samples
oldls       long 0
oldrs       long 0

ls0         long 0
rs0         long 0

ls          long 0    
rs          long 0

oldsample   long 0
newsample   long 0

nrsample    long 0
nlsample    long 0


dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
'dac        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   

'-----------------------------------------------------------------------------------------
'------ PASM driver ends here ------------------------------------------------------------
'----------------------------------------------------------------------------------------- 

'
dat 
null  			long 	0,0           ' for channel reset
