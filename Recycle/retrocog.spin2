' A retromachine cog
' The purpose: to read/send and process data from RPi and Midi Shield
' v. 0.00 pik33@o2.pl
'
con

rxpin=32
txpin=33
midiin=29
midiout=30
baudrate=1920000
mbaudrate=31250

var

long commandptr
long recvptr
long midiinptr
long bitmodeptr
long mbitmodeptr
long r_rxpin
long r_txpin
long m_in
long m_out


long command
long r_recv
long m_recv
long r_bitmode
long m_bitmode



pub start() :cog

serial_start(rxpin, txpin, baudrate)
midi_start(midiin,midiout,mbaudrate)



pub retrospin()







' init the serials


'' v. 0.01 - initial                                                            '
'' pik33@o2.pl                                                                  '
''------------------------------------------------------------------------------'

con

hdmi_base       = 0            'must be a multiple of 8
'_clkfreq        = 354_689_500   '200x Atari 8-bit PAL,  50x Amiga PAL
'_clkfreq       = 357_954_500   '200x Atari 8-bit NTSC, 50x Amiga NTSC
_clkfreq		= 320_000_000    'will be set via video driver
rxpin           = 32
txpin           = 33
baudrate        = 1920000


obj

v:    "hng030rm"

var

long vgacog
long sdcog
long rxp
long txp
long mrxp
long mtxp
long serialbuf[64]
long serialtail,serialfront
long serialstack[64]
long rr,mrr
byte charcode
byte scancode
byte mousewheel
byte mousekey
word mousex
word mousey
byte dummy

pub start(mode)   |iii,caps

mode :=64+6
caps:=0
pinl(31)
waitms(100)
iii:=0
vgacog:=v.start(mode,hdmi_base)
'v.setmode(mode+64)
v.setfontfamily(0)
v.cls(154,147)
v.setbordercolor(0,0,0)
serial_start(rxpin, txpin, baudrate)
midi_start(29,30)
pinwrite(14,0)
pinwrite(15,0)

cogspin(16,serialcog(),@serialstack)
v.setcursorshape(0)
v.setwritecolors(154,147)
v.writeln(string(" "))
v.writeln(string("  P2 Retromachine v. 0.00"))
v.writeln(string(" "))
v.writeln(string("  Ready"))
v.writeln(string(" "))
v.write(string("  "))

iii:=fileopen(string("C:\kernel.img"))

repeat
 
  repeat 
    rr:=serialread()
    mrr:=mrxcheck()
 '   debug(udec(mrr))
  until rr>=0 || mrr>=0  
    
'  rr:=serialblockingread()

{{
  if rr==$38
    scancode:=serialblockingread()
    charcode:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
      if charcode==185 'caps
        if caps==0
          caps:=1
        else
          caps:=0
      if charcode==136 'bksp
        v.bksp()



      if charcode<128
        v.putchar(charcode)
      if charcode==141
        v.crlf()

}}   
  if mrr>=0
    v.write(string(" Midi: "))
    v.writeln(v.inttohex(mrr,2))
    
 
  if rr==$31    'mousex
    mousex:=serialblockingread()
    mousex+=serialblockingread()<<8
    rr:=serialblockingread()
    if rr==255
     v.write(string("  Mouse moved, x= "))
     v.write(v.inttostr(mousex))
     v.write(string(", y= "))
     v.writeln(v.inttostr(mousey))

  if rr==$32    'mousey
    mousey:=serialblockingread()
    mousey+=serialblockingread()<<8
    rr:=serialblockingread()
    if rr==255
     v.write(string("  Mouse moved, x= "))
     v.write(v.inttostr(mousex))
     v.write(string(", y= "))
     v.writeln(v.inttostr(mousey))

  if rr==$33   'mousewheel
    mousewheel:=serialblockingread()
    dummy:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
     v.write(string("  Mouse wheel: "))
     v.writeln(v.inttostr(mousewheel))

  if rr==$34   'mousekey
    mousekey:=serialblockingread()
    dummy:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
     v.write(string("  Mouse key pressed: "))
     v.writeln(v.inttostr(mousekey))

  if rr==$35   'mouseclick
    dummy:=serialblockingread()
    dummy:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
     v.writeln(string("  Mouse clicked"))

  if rr==$36   'mouseclick
    dummy:=serialblockingread()
    dummy:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
     v.writeln(string("  Mouse double clicked"))

  if rr==$37   'key released
    scancode:=serialblockingread()
    dummy:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
     v.write(string("  Key scancode "))
     v.write(v.inttostr(scancode))
     v.writeln(string(" released"))

  if rr==$38   'key pressed
    scancode:=serialblockingread()
    charcode:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
     v.write(string("  Key scancode "))
     v.write(v.inttostr(scancode))
     v.write(string(", charcode "))
     v.write(v.inttostr(charcode))
     v.writeln(string(" pressed"))

  if rr==$39   'modifier pressed
    scancode:=serialblockingread()
    dummy:=serialblockingread()
    rr:=serialblockingread()
    if rr==255
      if scancode>0
        v.write(string("  Key modifier "))
        v.write(v.inttostr(scancode))
        v.writeln(string(" pressed"))
        if scancode==1
          v.setmode (0)
          serial_start(rxpin, txpin, baudrate)
          midi_start(29,30)
        if scancode==8
          v.setmode(64)  
          serial_start(rxpin, txpin, baudrate)
          midi_start(29,30)
      else
        v.writeln(string("  Modifiers released"))

 

pub fileopen(filename) :r       |q ,i

q:=strsize(filename)
tx($40)
repeat i from 0 to q-1
  tx(byte[filename+i])
tx(255)
return q


pub serialcog()|q

serialfront:=0
serialtail:=0

repeat
  if serialfront<>((serialtail-1) //32)
    q:=rxcheck()
    if q>=0
     serialbuf[serialfront]:=q
     serialfront+=1
     serialfront:=serialfront // 32

pub serialread():r

if serialfront<>serialtail
  r:=serialbuf[serialtail]
  serialtail:=(serialtail+1)//32
else
  r:=-1
return r

pub serialblockingread(): r

repeat
  r:=serialread()
until r<>-1
return r



''---------------------- Serial functions from jm_serial.spin2

pub serial_start(rxpin2, txpin2, baud) | bitmode

'' Start simple serial coms on rxpin and txpin at baud

'  longmove(@rxp, @rxpin2, 2)                                     ' save pins

  rxp:=rxpin2
  txp:=txpin2

  bitmode := muldiv64(clkfreq, $1_0000, baud) & $FFFFFC00       ' set bit timing
  bitmode |= 7                                                  ' set bits (8)

  org
                fltl      rxpin2                                 ' configure rx smart pin
                wrpin     ##P_ASYNC_RX, rxpin2
                wxpin     bitmode, rxpin2
                drvl      rxpin2
                fltl      txpin2                                ' configure tx smart pin
                wrpin     ##(P_ASYNC_TX | P_OE), txpin2
                wxpin     bitmode, txpin2
                drvl      txpin2
  end

pub midi_start(mrxpin2, mtxpin2) | bitmode

'' Start simple serial coms on rxpin and txpin at baud

'  longmove(@rxp, @rxpin2, 2)                                     ' save pins

  mrxp:=mrxpin2
  mtxp:=mtxpin2

  bitmode := muldiv64(clkfreq, $1_0000, 31250) & $FFFFFC00       ' set bit timing
  bitmode |= 7                                                  ' set bits (8)

  org
                fltl      mrxpin2                                 ' configure rx smart pin
                wrpin     ##P_ASYNC_RX, mrxpin2
                wxpin     bitmode, mrxpin2
                drvl      mrxpin2
                fltl      mtxpin2                                ' configure tx smart pin
                wrpin     ##(P_ASYNC_TX | P_OE), mtxpin2
                wxpin     bitmode, mtxpin2
                drvl      mtxpin2
  end


pub rxflush()

'' Clear serial input

  repeat
  while (rxcheck() >= 0)


pub rxcheck() : rxbyte | check

'' Check for serial input
'' -- returns -1 if nothing available

  rxbyte := -1
  check := pinr(rxp)
  if (check)
    rxbyte := rdpin(rxp) >> 24


pub rxtime(ms) : b | mstix, t

'' Wait ms milliseconds for a byte to be received
'' -- returns -1 if no byte received, $00..$FF if byte

  mstix := clkfreq / 1000

  t := getct()
  repeat
  until ((b := rxcheck()) >= 0) or (((getct() - t) / mstix) > ms)


pub rx() : rxbyte

'' Wait for serial input
'' -- blocks!

  repeat
    rxbyte := rxcheck()
  until (rxbyte >= 0)


pub tx(b)

'' Emit byte

  wypin(txp, b)
  txflush()

pub txflush() | check

'' Wait until last byte has finished

  repeat
    check := pinr(txp)
  while (check == 0)


pub mrxflush()

'' Clear serial input

  repeat
  while (mrxcheck() >= 0)


pub mrxcheck() : rxbyte | check

'' Check for serial input
'' -- returns -1 if nothing available

  rxbyte := -1
  check := pinr(mrxp)
  if (check)
    rxbyte := rdpin(mrxp) >> 24


pub mrxtime(ms) : b | mstix, t

'' Wait ms milliseconds for a byte to be received
'' -- returns -1 if no byte received, $00..$FF if byte

  mstix := clkfreq / 1000

  t := getct()
  repeat
  until ((b := mrxcheck()) >= 0) or (((getct() - t) / mstix) > ms)


pub mrx() : rxbyte

'' Wait for serial input
'' -- blocks!

  repeat
    rxbyte := mrxcheck()
  until (rxbyte >= 0)


pub mtx(b)

'' Emit byte

  wypin(mtxp, b)
  mtxflush()

pub mtxflush() | check

'' Wait until last byte has finished

  repeat
    check := pinr(mtxp)
  while (check == 0)





pub dummy()

' this is an object
start()
repeat
    
  
pub start():cog

r_bitmode := muldiv64(clkfreq, $1_0000, 1920000) & $FFFFFC00       ' set bit timing
r_bitmode |= 7   
m_bitmode := muldiv64(clkfreq, $1_0000, 1920000) & $FFFFFC00       ' set bit timing
m_bitmode |= 7   

commandptr:=@command
recvptr:=@r_recv
midiinptr:=@m_recv
bitmodeptr:=@r_bitmode
mbitmodeptr:=@m_bitmode
r_rxpin:=rxpin
r_txpin:=txpin
m_in:=midiin
m_out:=midiout


cog:=coginit(16, @retro, @commandptr)
return cog


dat 		org

retro       setq #8
			rdlong c_ptr,ptra

			rdlong bitmode,bm_ptr
			rdlong mbitmode,mbm_ptr

			fltl rxpin1
			fltl txpin1
			fltl midiinpin
			fltl midioutpin

            wrpin	##P_ASYNC_RX, rxpin1
            wxpin  	bitmode, rxpin1            
            drvl   	rxpin1
            wrpin	##(P_ASYNC_TX | P_OE), txpin1
            wxpin   bitmode, txpin1
            drvl    txpin1
            wrpin   ##P_ASYNC_RX, midiinpin
            wxpin   mbitmode, midiinpin           
            drvl    midiinpin
            wrpin   ##(P_ASYNC_TX | P_OE), midioutpin
            wxpin   bitmode, midioutpin
            drvl    midioutpin
                     
 
p101       ' read command.  01 read serial, 02 read midi, 00 do nothing, TODO FF-set baud rate, FE set midi baud rate,
			rdlong 	cmd,c_ptr
			cmp 	cmd,#1 wz
	if_z	call	#serialrecv	
			cmp		cmd,#2 wz
	if_z	call	#midirecv
		
			

     		testp  	rxpin1 wc
       if_c	rdpin	serialin1,rxpin1	
            shr		serialin1,#24
       if_c call	#serialqadd
            testp   midiinpin wc
       if_c	rdpin	midiin1,midiinpin 
       		shr		midiin1,#24	
       if_c call	#midiqadd
            
            jmp     #p101      
             
''  todo: send queues and send             
    
      
    
serialqadd	mov 	a1,serialtail
			sub 	a1,#1
			and     a1,#%11111
			mov 	a2,serialfront
			and		a2,#%11111
			cmp		a2,a1 wz
    if_nz   add		serialfront,serialstart			
	if_nz	wrlut   serialin1,serialfront
	if_nz	add 	serialfront,#1
    _ret_	and		serialfront,#%11111
			
				
midiqadd	mov 	a1,miditail
			sub 	a1,#1
			and     a1,#%11111
			mov 	a2,midifront
			and		a2,#%11111
			cmp		a2,a1 wz
    if_nz   add		midifront,midistart			
	if_nz	wrlut   midiin1,midifront
	if_nz	add 	midifront,#1
    _ret_	and		midifront,#%11111	
    
'' These procedures waste the lut ram: todo: try to pack data    	


serialrecv  cmp 	serialtail,serialfront wz
	if_z	mov 	recv,#511
	if_z	ret
			mov 	a1,serialtail
			add		a1,serialstart
			rdlut	recv,a1
			wrlong	recv,r_ptr
			wrlong 	#0,c_ptr
			add 	serialtail,#1
	_ret_	and		serialtail,#%11111
	
midirecv  	cmp 	miditail,midifront wz
	if_z	mov 	mrecv,#511
	if_z	ret
			mov 	a1,miditail
			add		a1,midistart
			rdlut	mrecv,a1
			wrlong	mrecv,m_ptr
			wrlong 	#0,m_ptr
			add 	miditail,#1
	_ret_	and		miditail,#%11111
	
			
midistart	long 0
serialstart long 32
serialfront long 0
serialtail 	long 0
midifront	long 0
miditail	long 0		
recv 		long 0
mrecv		long 0
a1 			long 0
a2 			long 0
cmd			long 0
c_ptr		long 0
r_ptr		long 0
m_ptr		long 0
bm_ptr		long 0
mbm_ptr		long 0
rxpin1		long 0
txpin1		long 0
midiinpin   long 0
midioutpin 	long 0
bitmode		long 0
mbitmode	long 0
serialin1	long 0
midiin1		long 0
