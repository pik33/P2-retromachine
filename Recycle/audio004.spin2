_clkfreq=319220550 ' 90*3546895 

con left=14
    right=15

    freql=440
    freqr=440

c4=262
d4=294
e4=330
f4=349
g4=392
a4=440
h4=494


var

long samplestart
long sampletype
long loopstart
long loopend         'loopstart==loopend=no loop
long volume
long pan
long synthfreq
long skip
long cmd

long samplestart2
long sampletype2
long loopstart2
long loopend2         'loopstart==loopend=no loop
long volume2
long pan2
long synthfreq2
long skip2
long cmd2

long samplestart3
long sampletype3
long loopstart3
long loopend3         'loopstart==loopend=no loop
long volume3
long pan3
long synthfreq3
long skip3
long cmd3

long samplestart4
long sampletype4
long loopstart4
long loopend4         'loopstart==loopend=no loop
long volume4
long pan4
long synthfreq4
long skip4
long cmd4

long samplestart5
long sampletype5
long loopstart5
long loopend5         'loopstart==loopend=no loop
long volume5
long pan5
long synthfreq5
long skip5
long cmd5

long samplestart6
long sampletype6
long loopstart6
long loopend6     'loopstart==loopend=no loop
long volume6
long pan6
long synthfreq6
long skip6
long cmd6

long samplestart7
long sampletype7
long loopstart7
long loopend7         'loopstart==loopend=no loop
long volume7
long pan7
long synthfreq7
long skip7
long cmd7

long samplestart8
long sampletype8
long loopstart8
long loopend8        'loopstart==loopend=no loop
long volume8
long pan8
long synthfreq8
long skip8
long cmd8




pub test

start()
repeat
  waitms(5000)
waitms(5000)
waitms(5000)
waitms(5000)
waitms(5000)

samplestart:=@synvox+16
sampletype:=1
loopstart:=27299
loopend:=27300
volume:=16384
pan:=8192
synthfreq:=300
skip:=1
cmd:=0
waitus(10)
cmd:=1


waitms(5000)
repeat
 play(c4)
 waitms(500)
 play(d4)
 waitms(500)
 play(e4)
 waitms(500)
 play(f4)
 waitms(500)
 play(g4)
 waitms(500)
 play(a4)
 waitms(500)
 play(h4)
 waitms(500)
 play(2*c4)
 waitms(500)
 play(5)
 waitms(500)
 play(2*c4)
 waitms(500)
 play(h4)
 waitms(500)
 play(a4)
 waitms(500)
 play(g4)
 waitms(500)
 play(f4)
 waitms(500)
 play(e4)
 waitms(500)
 play(d4)
 waitms(500)
 play(c4)
 waitms(500)
 play(5)
 waitms(500)

pub play(ff) |ilss,ss,ssf

'keep ssf over 50

ilss:=20000/ff
ss:=2*(1024/ilss)
if ss<2
  ss:=2
ssf:=(ss*3568945)/(ff*2048)
'debug(udec(ssf))
'debug(udec(ilss))
'debug(udec(ss))

samplestart:=@sinewave+16
sampletype:=0
loopstart:=0
loopend:=2048
volume:=16384
pan:=0
synthfreq:= ssf
skip:= ss

cmd:=0
waitus(10)
cmd:=1

pub start()


samplestart:=@sinewave
sampletype:=0
loopstart:=16
loopend:=2048
volume:=16384
pan:=16384
synthfreq:=12
skip:=2
cmd:=0

samplestart2:=@sinewave
sampletype2:=0
loopstart2:=16
loopend2:=2048
volume2:=16384
pan2:=0
synthfreq2:=19
skip2:=2
cmd2:=0

coginit(16,@audio,@samplestart)

cmd:=1
cmd2:=1
dat

audio   org
		dirh #56
		outh #56
        setq #8
        rdlong sstart,ptra
        
        wrpin   dac,#left
        wxpin   ##90,#left

        wrpin   dac,#right
        wxpin   ##90,#right

        dirh    #left addpins 1

        setse1  #%001<<6 + left
        
'        mov start,ptra
 '       add start,#16
        
        mov ijmp1,#isr1       
        setint1 #4 
        
        mov time,#1
loop    

'find nearest time
'compute sample
'put to lut sample, time
'get new time for this channel
'wait until free place in lut



         


            setq #8
            rdlong sstart,ptra++
            setq #8
            rdlong sstart2,ptra++
'            setq #8
'            rdlong sstart3,ptra++

            sub ptra,#9*4*2
 
   
            cmp acmd,#0 wz
         if_e mov p1,#0
           cmp acmd2,#0 wz
         if_e mov p2,#0
'           cmp acmd3,#0 wz
'         if_e mov p3,#0

         
           	mov cn,#0
           	mov ct,time1
           	fle ct, time2 wcz
	if_c	mov cn,#1
'          fle ct,time3 wcz
'           if_c mov cn,#2

           
           
'nov qq is the lowest time, cn is the channel           
             
          

'       if_e add time1,#$1FF     
            

 
           'time0 - last sample time
           
           ' find the nearest time of 8 channels
           '
         	mov qq,tail  ' this has to be set at the front
        	sub qq,#2
        	and qq,#511
        	cmp qq,front wcz
	if_e    jmp #loop           ' buffer full          
	
	
	
	         cmp cn, #0 wz
     if_z jmp #p201       
         cmp cn, #1 wz
      if_z jmp #p202       
            
	
	
	
'----1	
	
 
p201 		
            add p1,askip
            cmp p1,lend wcz
    if_ge   sub p1,lend	        
    if_ge   add p1,lstart       

            mov p12,p1
            add p12,sstart
            cmp type,#0 wz
            
	if_nz	rdbyte spl,p12
	if_nz 	sub spl,#$80
	if_nz	shl spl,#8
	if_z 	rdword spl,p12


         	scas spl,vol
         	mov spl,0-0
    	
	    	scas spl,apan
	    	mov ls,0-0
	    	bitnot ls,#15

	    	mov qq,##16384
	    	sub qq,apan
	    	scas spl,qq
	    	mov rs,0-0
	    	bitnot rs,#15
	    	setword rs,ls,#1

 '       	debug(udec(time1))
	    	mov time0,time1    	
	        add time1,freq	    	
	    	jmp #p101

''=-------------2
 
p202 		

  	
            add p2,askip2
            cmp p2,lend2 wcz
    if_ge   sub p2,lend2	        
    if_ge   add p2,lstart2       

            mov p22,p2
            add p22,sstart2
            cmp type2,#0 wz
            
	if_nz	rdbyte spl2,p22
	if_nz 	sub spl2,#$80
	if_nz	shl spl2,#8
	if_z 	rdword spl2,p22


         	scas spl2,vol2
         	mov spl,0-0
    	
	    	scas spl2,apan2
	    	mov ls,0-0
	    	bitnot ls,#15

	    	mov qq,##16384
	    	sub qq,apan2
	    	scas spl2,qq
	    	mov rs,0-0
	    	bitnot rs2,#15
	    	setword rs2,ls2,#1
	
		   	mov time0,time2
    	    add time2,freq2
 '       	debug(udec(time1))
    	jmp #p101

p101      
     '       cmp oldt0,time0 wz
  ' if_z		sub front,#2
  ' if_z     and front,#511     
  
  
 '           debug(udec(cn))
 '          debug(udec(front))
 '          debug(udec(time0))
 '          debug(udec(rs))
 '          debug(udec(counter))
 
 			add rs,rs2
            wrlut rs,front
            add front,#1
            wrlut time0,front

            add front,#1
            and front,#511
            mov oldt0,time0
            jmp     #loop          'loop

'--------------------------------------------------------------------------
'--- Interrupt. Output the sample, get the next one

isr1       	outh #56
            wypin lsample,#left  '2        
		    wypin rsample,#right '4

			add counter,#1        '6
			cmp counter,time wcz  '8
	if_le	reti1			      'if too early for the next sample, do nothing '10
		
            cmp tail,front wcz    'if the buffer is empty, do nothing '12
	if_e	reti1                 '14

            rdlut lsample,tail    '17
            getword rsample,lsample,#1 '19
            getword lsample,lsample,#0 '21
            add tail, #1                '23
            rdlut time,tail             '26
            add tail,#1                 '28
            and tail,#511               '30
            outl #56
            reti1                       '34

'---------------------------------------------------------------------------
        
x       long    0

p1      long    0
p2      long    0
p3	long 0
p4 long 0

p5 long 0
p6 long 0
p7 long 0
p8 long 0


f1  long 1
f2 long 0
p12 long 0
p22 long 0
front long 0
tail long 0
qq long 0
spl long 0
spl2 long 0
time long 0
counter long $FFF70000

lsample long 0
rsample long 0
amp     long    0

sstart long 0
type	long 0
lstart	long 0
lend     long 0                'loopstart==loopend=no loop
vol      long 16384
apan			long 32768
freq	long 200
askip		long 2
acmd			long 0

sstart2 long 0
type2	long 0
lstart2	long 0
lend2     long 0                'loopstart==loopend=no loop
vol2      long 16384
apan2			long 32768
freq2	long 200
askip2		long 2
acmd2			long 0

sstart3 long 0
type3	long 0
lstart3	long 0
lend3     long 0                'loopstart==loopend=no loop
vol3      long 16384
apan3			long 32768
freq3	long 200
askip3		long 2
acmd3			long 0

sstart4 long 0
type4	long 0
lstart4	long 0
lend4     long 0                'loopstart==loopend=no loop
vol4      long 16384
apan4			long 32768
freq4	long 200
askip4		long 2
acmd4			long 0

sstart5 long 0
type5	long 0
lstart5	long 0
lend5     long 0                'loopstart==loopend=no loop
vol5      long 16384
apan5			long 32768
freq5	long 200
askip5		long 2
acmd5			long 0

sstart6 long 0
type6	long 0
lstart6	long 0
lend6   long 0                'loopstart==loopend=no loop
vol6     long 16384
apan6			long 32768
freq6	long 200
askip6		long 2
acmd6			long 0

sstart7 long 0
type7	long 0
lstart7	long 0
lend7     long 0                'loopstart==loopend=no loop
vol7      long 16384
apan7			long 32768
freq7	long 200
askip7		long 2
acmd7			long 0

sstart8 long 0
type8	long 0
lstart8	long 0
lend8     long 0                'loopstart==loopend=no loop
vol8      long 16384
apan8			long 32768
freq8	long 200
askip8		long 2
acmd8			long 0

time0 long 0
time1 long 1
time2 long 2
time3 long 3
time4 long 4
time5 long 5
time6 long 6
time7 long 7
time8 long 8
oldt0 long 0
cn long 0
ct long 0

rs long 0
ls long 0
ls2 long 0
rs2 long 0



dac    long    %10111_00000000_01_00010_0      'random dither (noisier, needs no period)
'dac     long    %10111_00000000_01_00011_0      'pwm (quieter, needs 256N period)    


dat 
null  long 0,0
sinewave file "C:\s\sinus.s2"
zacke file "C:\s\zacke.s2"
synvox file "c:\xi\test.pcm"

{{
start mov ijmp1,#isr1 'set int1 vector 
setint1 #1 'set int1 for ct-passed-ct1 event 
getct ct1 'set initial ct1 target 
addct1 ct1,#50 'main program, gets interrupted 
loop drvnot #0 'toggle p0 
jmp #loop 'loop 'int1 isr, runs once every 50 clocks 
isr1 drvnot #1 'toggle p1 
addct1 ct1,#50 'update ct1 target 
reti1 'return to main program 
ct1 res 'reserve long for ct1
interrupt
add cnt,1
cmp cnt, time

if_eq wypin sample
if eq add tail,1
ifeq rdlut next time, nneext sample
iret

Program
find nearest time
compute sample
put to lut sample, time
get new time for this channel
wait until free place in lut
}}
