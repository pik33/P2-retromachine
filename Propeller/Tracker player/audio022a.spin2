' A Paula inspired sample based synthesizer/audio driver for a P2
' v. 0.21 alpha - 20220129
' MIT license
' Piotr Kardasz pik33@o2.pl
' 16 16-bit channels now
'-------------------------------------------------------------------
con

'319220550    =3546895, change to NTSC freq if needed
'322159050 ' This is 90x Amiga NTSC = 3579545
_clkfreq = 354693878  ' This is 100x Amiga PAL 3546895
' audio pins TODO: make a variable for start() instead of const

left= 14
right=15


c4=262
d4=294
e4=330
f4=349
g4=392
a4=440
h4=494

var

'channel+0  long current spl pointer - bit31=1 when 8bit spl
'channel+4  long sample
'channel+8  long sample start 
'channel+12 long loop start
'channel+16 long loop end
'channel+20 word volume
'channel+22 word pan
'channel+24 word synthfreq
'channel+26 word skip
'channel+28 long reserved
'

long channel1[8]
long channel2[8]
long channel3[8]
long channel4[8]
long channel5[8]
long channel6[8]
long channel7[8]
long channel8[8]
long channel9[8]
long channel10[8]
long channel11[8]
long channel12[8]
long channel13[8]
long channel14[8]
long channel15[8]
long channel16[8]


long primes[8]

'----------------------------------------------------------------
'------------  Alpha testing the thing --------------------------
'---------------------------------------------------------------- 

pub test

{{
start()
waitms(500)
repeat
  play(c4,5000,16384)
  play(d4,5000,16384)
  play(e4,5000,16384)
  play(f4,5000,16384)
  play(g4,5000,16384)
  play(a4,5000,16384)
  play(h4,5000,16384)
  play(2*c4,500,16384)
  play(c4,500,0)
  play(2*c4,500,16384)
  play(h4,500,16384)
  play(a4,500,16384)
  play(g4,500,16384)
  play(f4,500,16384)
  play(e4,500,16384)
  play(d4,500,16384)
  play(c4,500,16384)
  play(c4,500,0)

 
 
'----------------------------------------------------------------
'------------  An alpha test playing procedure ------------------
'------------  Plays sine waves in allchannels ------------------
'------------  makes a harmonic sound ---------------------------
'---------------------------------------------------------------- 

pub play(ff,time,vol) |ilss,ss,ssf,base,iii

' Test play 

ss:=64
ssf:=(ss*3568945)/(ff*2048)



base:=@channel1[0]

repeat iii from 0 to 0
  long [base+32*iii]:=0
  long [base+32*iii+4]:=0 
  long[base+32*iii+12]:=16
  long[base+32*iii+16]:=2048+16
  word[base+32*iii+20]:=vol/(iii+1)
  word[base+32*iii+22]:=8192
  word[base+32*iii+24]:=ssf
  word[base+32*iii+26]:=ss*(iii+1)
  long [base+32*iii+8]:=@sinewave | $C0000000  
repeat time
    waitms(1)

}}
'--------------------------------------------------------------
'---------- Init the variables, start the cog. ----------------
'--------------------------------------------------------------

pub start() :cog,base | iii

base:=@channel1[0]

repeat iii from 0 to 15
  long [base+32*iii]:=0
  long [base+32*iii+4]:=0
  long[base+32*iii+12]:=0
  long[base+32*iii+16]:=2 
  word[base+32*iii+20]:=0
  word[base+32*iii+22]:=8192
  word[base+32*iii+24]:=400+2*iii
  word[base+32*iii+26]:=2
  long [base+32*iii+8]:=@null | $C0000000
  
cog:=coginit(16,@audio,@channel1)
waitms(100)
return cog,base

'--------------------------------------------------------------
'------ PASM driver code --------------------------------------
'-------------------------------------------------------------- 

dat

audio       org     0
            mov     ptrb,#0
            wrpin   dac,#left       ' Noise dither DACs at clk/90
            wxpin   #100,#left
            wrpin   dac,#right
            wxpin   #100,#right
            dirh    #left addpins 1
            setse1  #%001<<6 + left ' Set the event - DAC empty
            mov     ijmp1,#isr1     ' Init the interrupt
            setint1 #4              ' Interrupt from DAC empty event
            
'---------------------------------------------------------------------------------        
'----------------- The main loop -------------------------------------------------
'---------------------------------------------------------------------------------

loop        cmp     time0,a21000000 wc  ' time counter overflow protection
      if_c  jmp     #loop1
  
            mov     cn,#17
p402        altd    cn,#a21000000
            sub     0-0,a20000000
            djnz    cn,#p402
    
loop1       mov     cn,#0             ' Find the channel to compute
            mov     ct,time1           ' with the lowest next sample time
            fle     ct,time2 wcz       ' How to size-optimize this???
    if_c    mov     cn,#1
            fle     ct,time3 wcz
    if_c    mov     cn,#2     
            fle     ct,time4 wcz
    if_c    mov     cn,#3
            fle     ct,time5 wcz
    if_c    mov     cn,#4
            fle     ct,time6 wcz
    if_c    mov     cn,#5
            fle     ct,time7 wcz
    if_c    mov     cn,#6
            fle     ct,time8 wcz
    if_c    mov     cn,#7
            fle     ct,time9 wcz
    if_c    mov     cn,#8
            fle     ct,time10 wcz
    if_c    mov     cn,#9
            fle     ct,time11 wcz
    if_c    mov     cn,#10
            fle     ct,time12 wcz
    if_c    mov     cn,#11
            fle     ct,time13 wcz
    if_c    mov     cn,#12
            fle     ct,time14 wcz
    if_c    mov     cn,#13
            fle     ct,time15 wcz
    if_c    mov     cn,#14
            fle     ct,time16 wcz
    if_c    mov     cn,#15



'----------------------------------------------------------------------------------
'------------- Compute channel samples --------------------------------------------
'----------------------------------------------------------------------------------


p401        mov     channeladd,cn              '
            shl     channeladd,#5
            add     ptra,channeladd

            setq    #7               
            rdlong  pointer0,ptra
            getword oldls,sample0,#0
            getword oldrs,sample0,#1

     	    getword apan0,volpan0,#1           ' extract vol,pan,skip and freq from longs 
    	    getword avol0,volpan0,#0
	        getword askip0,freqskip0,#1    	    
	        getword afreq0,freqskip0,#0

          alts    cn, #time1
          mov     dt0,0-0   
          sub     dt0,time0

   



           altd    cn, #time1
           add     0-0,afreq0  	

            add     pointer0,askip0
            cmp     pointer0,lend0 wcz
    if_ge   sub     pointer0,lend0	        
    if_ge   add     pointer0,lstart0       
            mov     qq,pointer0
            add     qq,sstart0

            testb   sstart0,#31 wz

    if_nz   rdbyte  spl,qq
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq

            scas    spl,avol0
            mov     spl,0-0
 
            scas    spl,apan0
            mov     ls0,0-0
 
             
            mov     qq,##16384
            sub     qq,apan0
            scas    spl,qq
            mov     rs0, 0-0

   
            sub rs,oldrs
            add rs,rs0
            sub ls,oldls
            add ls,ls0
   
            setword sample0,rs0,#1
            setword sample0,ls0,#0
            
            bitl   sstart0, #30 wcz            
    if_z    mov    pointer0, #0  
    if_z    wrlong sstart0, ptra[2]
p403        setq #1
     
            wrlong  pointer0,ptra
            sub     ptra, channeladd
            jmp     #p101
                       
            
                      
'------------------------ Channels end here --------------------       

' Now add all channels and put the sample to the buffer    


p101        cmp     oldt0,time0 wz '  If 2 samples have the same time, update instead of write
    if_z    decmod front, ##511        ' 
 '   if_z    and     front,#511     
           
            wrlong front,#$60

           mov oldls, ls
 		    mov oldrs,rs
            bitnot  oldls,#15            ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
            bitnot  oldrs,#15		      ' and these with $FFFF if a filter should be applied
		    
            setword oldrs,oldls,#1         ' Pack L and R to one long    		
            mov oldsample, newsample
            mov newsample, oldrs

            mov     oldt0,time0      ' update global time
            add     time0,dt0    
                                      ' now push dt0 samples to the buffer
            cmp      dt0,#0 wz
    if_z    jmp      #loop1
            mov      t1,dt0
  
p301        alts    ptrb,#511          ' checking if the buffer is full - Wuerfel_21's magic stuff
            cmpr    front, #0-0 wcz
    if_e    jmp     #p301    
			    
            wrlut   oldsample, front
            incmod front, ##511
            djnz    t1,#p301
            
            jmp     #loop            'loop

'-------------------------------------------------------------------------
'------------------ This is the end of the main loop ---------------------
'-------------------------------------------------------------------------

'--------------------------------------------------------------------------
'------ Interrupt service -------------------------------------------------
'------ Output the sample, get the next one if exists ---------------------
'--------------------------------------------------------------------------

isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
            wypin   rsample,#right       '4
            cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
    if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
    if_ne   incmod  ptrb,#511
    if_ne   getword rsample,lsnext,#1    '13
    if_ne   getword lsample,lsnext,#0    '15
            reti1                        '17/19 
          
'---------------------------------------------------------------------------
'-------- End of interrupt -------------------------------------------------
'---------------------------------------------------------------------------    


'---------------------------------------------------------------------------
'------- Variables ---------------------------------------------------------
'---------------------------------------------------------------------------

' constants

a20000000   long $10000000
a21000000   long $11000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before

' Time variables

time0       long 0    ' Global sample computing time
time1       long 1    ' Local channels time
time2       long 2
time3       long 3
time4       long 4
time5       long 5
time6       long 6
time7       long 7
time8       long 8
time9       long 9
time10       long 10
time11       long 11
time12      long 12
time13       long 13
time14       long 14
time15      long 15
time16      long 16


oldsample long 0
newsample long 0
'
t1 long 0
t2 long 0
'
nrsample long 0
nlsample long 0
'
channeladd long 0


front       long 0

' temporary variables 
'
qq          long 0
spl         long 0



' Interrupt ISR variables


lsample     long 0
rsample     long 0
lsnext      long 0
rsnext      long 0 


pointer0    long 0
sample0     long 0
sstart0     long 0     ' start pointer and type at bit 31
lstart0     long 0
lend0       long 0
volpan0     long 0
freqskip0   long 0
ctime0      long 0

afreq0      long 0
askip0      long 0
avol0       long 0
apan0       long 0

oldt0       long $FFFFFFFF    'Temporary time variables
cn          long 0
ct          long 0
dt0         long 0

' Samples
oldls long 0
oldrs long 0

ls0         long 0
rs0         long 0
channel     long 0
ls          long 0    ' Global sample variable
rs          long 0



dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
'dac        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   

'-----------------------------------------------------------------------------------------
'------ PASM driver ends here ------------------------------------------------------------
'----------------------------------------------------------------------------------------- 

'
dat 

null  			long 	0,0           ' for channel reset
'sinewave 		file 	"sinus.s2"    ' for testing
