' A Paula inspired sample based synthesizer/audio driver for a P2
' v. 0.90 beta - 20220131
' MIT license
' Piotr Kardasz pik33@o2.pl with the help from P2 forum community :) 
' 8 channel version
'-------------------------------------------------------------------
con

_clkfreq = 354693878  ' This is 100x Amiga PAL 3546895


left= 14
right=15

c4=262
d4=294
e4=330
f4=349
g4=392
a4=440
h4=494

var

'channel+0  long current spl pointer
'channel+4  long sample
'channel+8  long sample start 
'channel+12 long loop start
'channel+16 long loop end
'channel+20 word volume
'channel+22 word pan
'channel+24 word synthfreq
'channel+26 word skip
'channel+28 long reserved
'

long channel1[8]
long channel2[8]
long channel3[8]
long channel4[8]
long channel5[8]
long channel6[8]
long channel7[8]
long channel8[8]


pub test

 
start()
waitms(500)
repeat
  play(c4,500,16384)
  play(d4,500,16384)
  play(e4,500,16384)
  play(f4,500,16384)
  play(g4,500,16384)
  play(a4,500,16384)
  play(h4,500,16384)
  play(2*c4,500,16384)
  play(c4,500,0)
  play(2*c4,500,16384)
  play(h4,500,16384)
  play(a4,500,16384)
  play(g4,500,16384)
  play(f4,500,16384)
  play(e4,500,16384)
  play(d4,500,16384)
  play(c4,500,16384)
  play(c4,500,0)



pub play(ff,time,vol) |ilss,ss,ssf,base,iii

' Test play 

ss:=64
ssf:=(ss*3568945)/(ff*2048)



base:=@channel1[0]

repeat iii from 0 to 7
  long[base+32*iii+12]:=16
  long[base+32*iii+16]:=2048+16
  word[base+32*iii+20]:=vol/(2*(iii+1))
  word[base+32*iii+22]:=8192
  word[base+32*iii+24]:=ssf
  word[base+32*iii+26]:=ss*(iii+1)
  long [base+32*iii+8]:=@sinewave | $C0000000  
repeat time
    waitms(1)
'--------------------------------------------------------------
'---------- Init the variables, start the cog. ----------------
'--------------------------------------------------------------

pub start() :cog,base | iii

base:=@channel1[0]

repeat iii from 0 to 7
  long[base+32*iii]:=0
  long[base+32*iii+4]:=0
  long[base+32*iii+12]:=0
  long[base+32*iii+16]:=2 
  word[base+32*iii+20]:=0
  word[base+32*iii+22]:=8192
  word[base+32*iii+24]:=400+2*iii
  word[base+32*iii+26]:=2
  long [base+32*iii+8]:=@null | $C0000000
  
cog:=coginit(16,@audio,@channel1)
waitms(100)
return cog,base

'--------------------------------------------------------------
'------ PASM driver code --------------------------------------
'-------------------------------------------------------------- 

dat

audio       org     0
            mov     ptrb,#0             ' A tail pointer for the buffer
            wrpin   dac,#left           ' Noise dither DACs at clk/100
            wxpin   #100,#left       
            wrpin   dac,#right
            wxpin   #100,#right    
            dirh    #left addpins 1
            setse1  #%001<<6 + left     ' Set the event - DAC empty
            mov     ijmp1,#isr1         ' Init the interrupt
            setint1 #4                  ' Interrupt from DAC empty event
            
'---------------------------------------------------------------------------------        
'----------------- The main loop -------------------------------------------------
'---------------------------------------------------------------------------------

loop        cmp     time0,a41000000 wc  ' time counter overflow protection
      if_c  jmp     #loop1
  
            mov     cn,#9            ' Substract $40000000 from all the channel times and the main timer
p402        altd    cn,#a41000000       ' this has to be done at once
            sub     0-0,a40000000
            djnz    cn,#p402
    
loop1       mov     cn,#0               ' Find the channel to compute
            mov     ct,time1            ' with the lowest next sample time
            fle     ct,time2 wcz        ' How to size-optimize this???
    if_c    mov     cn,#1
            fle     ct,time3 wcz
    if_c    mov     cn,#2     
            fle     ct,time4 wcz
    if_c    mov     cn,#3
            fle     ct,time5 wcz
    if_c    mov     cn,#4
            fle     ct,time6 wcz
    if_c    mov     cn,#5
            fle     ct,time7 wcz
    if_c    mov     cn,#6
            fle     ct,time8 wcz
    if_c    mov     cn,#7


'----------------------------------------------------------------------------------
'------------- Compute channel samples --------------------------------------------
'----------------------------------------------------------------------------------


p401        mov     channeladd,cn             ' compute the pointer to channel parameters block
            shl     channeladd,#5
            add     ptra,channeladd

            setq    #7                        ' read parameters
            rdlong  pointer0,ptra
            
            getword oldls,sample0,#0          ' extract old sample value
            getword oldrs,sample0,#1
     	    getword apan0,volpan0,#1          ' extract vol,pan,skip and freq from longs 
    	    getword avol0,volpan0,#0
            getword askip0,freqskip0,#1    	    
	        getword afreq0,freqskip0,#0

            alts    cn, #time1                ' compute the time difference between this and previous sample
            mov     dt0,0-0    
            sub     dt0,time0
            
            altd    cn, #time1                ' add channel period to channel time
            add     0-0,afreq0  	

            add     pointer0,askip0           ' compute the pointer to the next sample       
            cmp     pointer0,lend0 wcz
    if_ge   sub     pointer0,lend0	      ' and loop if needed     
    if_ge   add     pointer0,lstart0       
            mov     qq,pointer0               ' compute place in the hub memory from where the sample will be loaded
            add     qq,sstart0

            testb   sstart0,#31 wz            ' if bit #31 set, this is 16 bit sample, else it is 8 bit

    if_nz   rdbyte  spl,qq                    ' 8 bit, read and shifr
    if_nz   shl     spl,#8
    if_z    rdword  spl,qq                    ' 16 bit, only read

            scas    spl,avol0                 ' apply volume
            mov     spl,0-0
 
            scas    spl,apan0                 ' apply pan
            mov     ls0,0-0
            mov     qq,##16384
            sub     qq,apan0
            scas    spl,qq
            mov     rs0, 0-0

            sub     rs,oldrs 		      ' replace the old sample with the new one in the mix
            add     rs,rs0
            sub     ls,oldls
            add     ls,ls0
   
            setword sample0,rs0,#1           ' pack samples into long
            setword sample0,ls0,#0
            
            bitl   sstart0, #30 wcz          ' if bit #30 of start pointer is set, the current pointer needs resetting  
    if_z    mov    pointer0, #0  
    if_z    wrlong sstart0, ptra[2]          ' reset bit #30 in hub

p403        setq #1                          ' write new pointer and sample value to the hub
            wrlong  pointer0,ptra
            sub     ptra, channeladd         ' reset the pointer to channel parameters
                      
            cmp     oldt0,time0 wz           '  If more than 1 sample is computed at the same time, write only the last result
    if_z    decmod  front, #511          
         
            getword oldls,ls,#0              ' reuse oldls variable to convert the sample to unsigned
 	        getword oldrs,rs,#0              ' getword instead of mov makes the upper bits=0
            bitnot  oldls,#15                ' convert to unsigned. TODO: compute and apply the gain for samples to not exceed 16 bit range
            bitnot  oldrs,#15		     ' warning: no filter here (yet) but before applying any, remember to and sample values with $FFFF and use signed samples 
	    
		    
            setword oldrs,oldls,#1           ' Pack L and R to one long    		
            mov     oldsample, newsample     ' The new computed sample will be outputted in the next loop, now we have to fill the buffer with the old one
            mov     newsample, oldrs       

            mov     oldt0,time0              ' update global time
            add     time0,dt0    
                                     
            cmp     dt0,#0 wz                ' now push dt0 samples to the buffer
    if_z    jmp     #loop1
            mov     qq,dt0
  
p301        alts    ptrb,#511                ' checking if the buffer is full - Wuerfel_21's magic stuff
            cmpr    front, #0-0 wcz
    if_e    jmp     #p301    
		
            		
			    
            wrlut   oldsample, front         ' if there is a free slot, put the sample into the buffer
            incmod  front, ##511
            djnz    qq,#p301
            
            jmp     #loop            'loop

'-------------------------------------------------------------------------
'------------------ This is the end of the main loop ---------------------
'-------------------------------------------------------------------------

'--------------------------------------------------------------------------
'------ Interrupt service -------------------------------------------------
'------ Output the sample, get the next one if exists ---------------------
'--------------------------------------------------------------------------

isr1        wypin   lsample,#left        '2     The sample has to be outputted every 100 cycles     
            wypin   rsample,#right       '4
            cmp     ptrb,front wcz       '6    If the buffer is empty, do nothing 
    if_ne   rdlut   lsnext,ptrb          '11    else read the sample and its time from LUT
    if_ne   incmod  ptrb,#511
    if_ne   getword rsample,lsnext,#1    '13
    if_ne   getword lsample,lsnext,#0    '15
    
            reti1                        '17/19 
          
'---------------------------------------------------------------------------
'-------- End of interrupt -------------------------------------------------
'---------------------------------------------------------------------------    


'---------------------------------------------------------------------------
'------- Variables ---------------------------------------------------------
'---------------------------------------------------------------------------

' constants

a40000000   long $40000000
a41000000   long $41000000  ' this const has to be immediately before time0 due to djnz loop initial pointer pointing one long before

' Time variables

time0       long 0    ' Global sample computing time
time1       long 1    ' Local channels time
time2       long 2
time3       long 3
time4       long 4
time5       long 5
time6       long 6
time7       long 7
time8       long 8


channeladd long 0

front       long 0

' temporary variables 
 
qq          long 0
spl         long 0

' Interrupt ISR variables

lsample     long 0
rsample     long 0
lsnext      long 0
rsnext      long 0 

' channel parameter block

pointer0    long 0     
sample0     long 0
sstart0     long 0     ' start pointer and type at bit 31
lstart0     long 0
lend0       long 0
volpan0     long 0
freqskip0   long 0
ctime0      long 0

afreq0      long 0
askip0      long 0
avol0       long 0
apan0       long 0

oldt0       long $FFFFFFFF    'Temporary time variables
cn          long 0
ct          long 0
dt0         long 0

' Samples
oldls       long 0
oldrs       long 0

ls0         long 0
rs0         long 0

ls          long 0    
rs          long 0

oldsample   long 0
newsample   long 0

nrsample    long 0
nlsample    long 0


dac         long %10111_00000000_01_00010_0     'random dither, as 90 cycles period needed
'dac        long %10111_00000000_01_00011_0     'pwm, left here for the future use, if any   

'-----------------------------------------------------------------------------------------
'------ PASM driver ends here ------------------------------------------------------------
'----------------------------------------------------------------------------------------- 

'
dat 
null  			long 	0,0           ' for channel reset
'sinewave 		file 	"sinus.s2"    ' for testing
