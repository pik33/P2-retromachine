_clkfreq=319220550 ' 90*3546895 

con left=14
    right=15


c4=262
d4=294
e4=330
f4=349
g4=392
a4=440
h4=494


var

long samplestart
long sampletype
long loopstart
long loopend         'loopstart==loopend=no loop
long volume
long pan
long synthfreq
long skip
long cmd

long samplestart2
long sampletype2
long loopstart2
long loopend2         'loopstart==loopend=no loop
long volume2
long pan2
long synthfreq2
long skip2
long cmd2



pub test

start()
repeat
  waitms(5000)

pub start()

samplestart:=@sinewave
sampletype:=0
loopstart:=16
loopend:=2048+16
volume:=8192
pan:=16384
synthfreq:=19
skip:=2
cmd:=0

samplestart2:=@sinewave
sampletype2:=0
loopstart2:=16
loopend2:=2048+16
volume2:=0
pan2:=0
synthfreq2:=19
skip2:=2
cmd2:=0

coginit(16,@audio,@samplestart)

cmd:=1
cmd2:=1
dat

audio   org
		dirh #56
		outh #56
        setq #17 ' chn#*9-1
        rdlong sstart1,ptra
        
        wrpin   dac,#left
        wxpin   ##90,#left

        wrpin   dac,#right
        wxpin   ##90,#right

        dirh    #left addpins 1

        setse1  #%001<<6 + left
        
        mov ijmp1,#isr1       
        setint1 #4 
        

loop    

     
            setq #8
            rdlong sstart1,ptra++
            setq #8
            rdlong sstart2,ptra++

            sub ptra,#9*4*2
    
            cmp acmd1,#0 wz
	if_e 	mov p1,#0
           	cmp acmd2,#0 wz
	if_e 	mov p2,#0
         
         	mov qq,tail   
        	sub qq,#2
        	and qq,#511
        	cmp qq,front wcz
	if_e    jmp #loop           ' buffer full               
         
         
           	mov cn,#0
           	mov ct,time1
           	fle ct,time2 wcz
	if_c	mov cn,#1
'                                   fle ct,time3 wcz
'                                   if_c mov cn,#2 ...
 	
	        cmp cn, #0 wz
	if_z 	jmp #p201       
         	cmp cn, #1 wz
	if_z 	jmp #p202       
            
	
	
	
'----1	
	
 
p201 		
            add p1,askip1
            cmp p1,lend1 wcz
    if_ge   sub p1,lend1	        
    if_ge   add p1,lstart1       

            mov p12,p1
            add p12,sstart1
            cmp type1,#0 wz
            
	if_nz	rdbyte spl1,p12
	if_nz 	sub spl1,#$80
	if_nz	shl spl1,#8
	if_z 	rdword spl1,p12

         	scas spl1,vol1
         	mov spl1,0-0
    	
	    	scas spl1,apan1
	    	mov ls1,0-0


	    	mov qq,##16384
	    	sub qq,apan1
	    	scas spl1,qq
	    	mov rs1,0-0
	    	bitnot rs1,#15

 '       	debug(udec(time1))
	    	mov time0,time1    	
	        add time1,freq1
  	bitnot ls1,#15
	    	jmp #p101

''=-------------2
 
p202 		

  	
            add p2,askip2
            cmp p2,lend2 wcz
    if_ge   sub p2,lend2	        
    if_ge   add p2,lstart2       

            mov p22,p2
            add p22,sstart2
            cmp type2,#0 wz
            
	if_nz	rdbyte spl2,p22
	if_nz 	sub spl2,#$80
	if_nz	shl spl2,#8
	if_z 	rdword spl2,p22


         	scas spl2,vol2
         	mov spl2,0-0
    	
	    	scas spl2,apan2
	    	mov ls2,0-0


	    	mov qq,##16384
	    	sub qq,apan2
	    	scas spl2,qq
	    	mov rs2,0-0
	    	bitnot rs2,#15
	    	setword rs2,ls2,#1
	
		   	mov time0,time2
    	    add time2,freq2
 '       	debug(udec(time1))
    	jmp #p101

p101      
	        	    		  
  
            cmp oldt0,time0 wz
   if_z		sub front,#2
   if_z     and front,#511     
  
  
 '           debug(udec(cn))
 '          debug(udec(front))
 '          debug(udec(time0))
 '          debug(udec(rs))
 '          debug(udec(counter))
 
 		'	add rs1,rs2
 		
	    	setword rs1,ls1,#1 		
            wrlut rs1,front
            add front,#1
            wrlut time0,front

            add front,#1
            and front,#511
            mov oldt0,time0
            jmp     #loop          'loop

'--------------------------------------------------------------------------
'--- Interrupt. Output the sample, get the next one

isr1       	outh #56
            wypin lsample,#left  '2        
		    wypin rsample,#right '4

			add counter,#1        '6
			cmp counter,irqtime wcz  '8
	if_le	reti1			      'if too early for the next sample, do nothing '10
		
            cmp tail,front wcz    'if the buffer is empty, do nothing '12
	if_e	reti1                 '14

            rdlut lsample,tail    '17
            getword rsample,lsample,#1 '19
            getword lsample,lsample,#0 '21
            add tail, #1                '23
            rdlut irqtime,tail             '26
            add tail,#1                 '28
            and tail,#511               '30
            outl #56
            reti1                       '34

'---------------------------------------------------------------------------
        


p1      long    0
p2      long    0


f1  long 1
f2 long 0

p12 long 0
p22 long 0

front long 0
tail long 0

qq long 0
spl1 long 0
spl2 long 0

counter long $FFF70000

lsample long 0
rsample long 0
 

sstart1 long 0
type1	long 0
lstart1	long 0
lend1     long 0                'loopstart==loopend=no loop
vol1      long 16384
apan1			long 32768
freq1	long 200
askip1		long 2
acmd1			long 0

sstart2 long 0
type2	long 0
lstart2	long 0
lend2     long 0                'loopstart==loopend=no loop
vol2      long 16384
apan2			long 32768
freq2	long 200
askip2		long 2
acmd2			long 0


time0 long 0
time1 long 1
time2 long 2
time3 long 3
time4 long 4
time5 long 5
time6 long 6
time7 long 7
time8 long 8
oldt0 long 0
cn long 0
ct long 0

rs1 long 0
ls1 long 0
ls2 long 0
rs2 long 0

irqtime long 0

dac    long    %10111_00000000_01_00010_0      'random dither (noisier, needs no period)
'dac     long    %10111_00000000_01_00011_0      'pwm (quieter, needs 256N period)    


dat 
null  long 0,0
sinewave file "C:\s\sinus.s2"
zacke file "C:\s\zacke.s2"
synvox file "c:\xi\test.pcm"

{{
start mov ijmp1,#isr1 'set int1 vector 
setint1 #1 'set int1 for ct-passed-ct1 event 
getct ct1 'set initial ct1 target 
addct1 ct1,#50 'main program, gets interrupted 
loop drvnot #0 'toggle p0 
jmp #loop 'loop 'int1 isr, runs once every 50 clocks 
isr1 drvnot #1 'toggle p1 
addct1 ct1,#50 'update ct1 target 
reti1 'return to main program 
ct1 res 'reserve long for ct1
interrupt
add cnt,1
cmp cnt, time

if_eq wypin sample
if eq add tail,1
ifeq rdlut next time, nneext sample
iret

Program
find nearest time
compute sample
put to lut sample, time
get new time for this channel
wait until free place in lut
}}
